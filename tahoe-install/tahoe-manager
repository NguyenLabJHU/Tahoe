#!/usr/bin/perl -w
#------------------------------------------------------------------------------
# tahoe-manager: 
#    a PERL script to checkout, configure, build and run regression tests
#    for TAHOE
# written by: 
#    Reese Jones (rjones@sandia.gov) and Patrick Klein (paklein@sandia.gov)
#------------------------------------------------------------------------------
# to do: parallel builds, deal with static libs e.g. access,
#
use Cwd; # $home = cwd();

# maps & constants
%module2define = qw(
expat	EXPAT_
toolbox	TB_
tahoe	NODEFINE
macros	NODEFINE
spooles SPOOLES_
f2c	F2C_
blas	BLAS_
access	AX_
);

@defaultmodules = ("macros","expat","toolbox","tahoe");

%syslib2module = qw(
ACCESS	access
);

%connect2command = qw(
cvs     cvs
http	curl
);

#default repository
$cvsrep = "tahoe.ca.sandia.gov:/cvs/protected/tahoe"; 

#default configuration file
$config_file = "./.tahoe_config";

# initialization
initialize();

# loop through arguments and options
$script_status = 0;
if (@ARGV < 1) {usage(); exit 0;}
ARG: while (@ARGV) {
	OPT: for (shift@ARGV) {
		$count = @ARGV;
		if ($script_status > 0 )   { failed();}
		if (/^u|update/i)          { update(); next ARG; }
		if (/^c|config/i)          { config(); next ARG; }
		if (/^b|build/i)           { build(); next ARG; }
		if (/clean/i)              { clean(); next ARG; }
		if (/^t|test/i)            { test(); next ARG; }
		if (/^a|all/i)             { update(); config(); build(); next ARG; }
		if (/^u|usage|help|^h/i)   { usage();}
		print "ERROR: unknown option: $_ \n"; usage();
	}
}

exit 0;

###############################################################################
sub initialize{
# username
$username = getlogin();

# classify modules
%tmp = %module2define;
foreach $key (@defaultmodules) {
	delete $tmp{$key};
}
@optionalmodules = keys (%tmp);
undef %tmp;

# search for system libs 
foreach $key (sort(keys %ENV)) {
	foreach $lib (keys %syslib2module) {
		if ($key =~ /$lib/ ) { 
			$loc = $ENV{$key};
			print "* found system library $lib \@ $loc \n"; 
			push(@syslibs,$lib);
		}
	}
}

# configuration file
if(-e "$config_file") { read_config();}
else                  { write_default_config();}

print ">   connection: $connection \n";
if ($proxy !~ /NONE/) {
	print ">        proxy: $proxy \n";
}
print "> architecture: $arch \n"; 

# check connection method
#open(WHICH, "which $connect2command{$connection} |");
if (my_which($connect2command{$connection}) =~ "") {
	print "ERROR: command \"$connect2command{$connection}\" not found\n";
	if ($connection =~ /http/) {
		print "ERROR: curl is available from http://curl.haxx.se/\n";
	}
 	exit;
}

# check cvs settings
if ($connection =~ /cvs/) {
	$cvs_OK = 0;
	foreach $key (sort(keys %ENV)) {
		if ($key =~ /CVS_RSH/ && $ENV{$key} =~ /ssh/) { $cvs_OK = 1; }
	}
	if ($cvs_OK != 1) {
		print "ERROR: CVS_RSH must be set to ssh\n";
		exit;
	}
}
}

##############################################################################
sub read_config{
print "* reading config file $config_file\n";
open(CONFIG,$config_file) || die "cannot open file $config_file for reading : $!";
$type = "UNKNOWN";
while(<CONFIG>) {
	s/^\s+//; s/\s+$//; @list = split(/ +/);
 	if (defined($list[0])){
        	if (/^\#/ ){ 
			if     ($type  =~ /CONNECTION/)
				{$connection = $tmp_list[0];}
			elsif  ($type  =~ /PROXY/){$proxy = $tmp_list[0];}
			elsif  ($type  =~ /ARCH/){$arch = $tmp_list[0];}
 			elsif  ($type  =~ /MODU/){@modules = @tmp_list;}
 			$type = $list[1]; @tmp_list =();
 		} 
 		else { push(@tmp_list,@list);}
 	}
}
close(CONFIG);

# need to make sure the core modules exist
foreach $core (@defaultmodules) {
	$found = 0;
	foreach $module (@modules) {
 		if($module =~ $core) { $found = 1;}
	}
	unless($found){
		print "* adding : $core, to modules\n";
 		push(@modules,$core);
 	}
}
}

##############################################################################
sub write_default_config{
print "* creating default config file $config_file\n";

# look for environmental settings
foreach $key (sort(keys %ENV)) {
	$value =  $ENV{$key};
	if ($key =~ /TAHOE_CONNECT/ ) {
		print "* found environmental var : $key = $value\n";
		$connection = $value;}
	if ($key =~ /TAHOE_ARCH/ ) { 
		print "* found environmental var : $key = $value\n";
		$arch = $value;}
	if ($key =~ /CVS_RSH/) { 
		print "* found CVS_RSH env var, using cvs connection\n"; 
		$connection = "cvs"; }
}

# connection type
$proxy = "NONE";
unless(defined($connection)){ 
@connections = ("cvs", "http");
$i=0;foreach $choice (@connections) { print "$i $choice\n"; $i++; }
print "connection type? [0]: ";
$i = <STDIN>; chomp($i);
if (length($i) == 0) { # default
	$i = 0;
}
$connection = $connections[$i];
if ($connection =~ /http/) { # ask for proxy
	print "http proxy (proxyhost:port) [NONE]:";
	$proxy = <STDIN>;
	chomp($proxy);
	if (length($proxy) == 0) { # default
		$proxy = "NONE";
	}
}
else {
        $cvs_OK = 0;
        foreach $key (sort(keys %ENV)) {
                if ($key =~ /CVS_RSH/ && $ENV{$key} =~ /ssh/) { $cvs_OK = 1; }
        }
        if ($cvs_OK != 1) {
                print "ERROR: CVS_RSH must be set to ssh\n";
                exit;
        }
}
}

# get macros module
unless(-d "macros") {
	if ($connection =~ /cvs/) {
		print "checking out macros\n";
		unlink("cvs.log");
		system("cvs -d $username\@$cvsrep checkout macros > cvs.log 2>&1");
	} elsif ($connection =~ /http/) {
	
		# grab new copy
		$curl_cmd = "curl http://tahoe.ca.sandia.gov/download/nightly/macros.tar.gz --remote-name --connect-timeout 10";
		if ($proxy !~ /NONE/) {
			$curl_cmd = $curl_cmd." --proxy $proxy";
		}
		system("$curl_cmd") == 0
			or die "ERROR: curl failed. Check connection or proxy ($proxy)";

		# unpack
		system("gunzip macros.tar.gz");
		system("tar xf macros.tar");
		system("rm macros.tar");
	}
	else {
		print "ERROR: unrecognized connection '$connection'\n";	
		exit;
	}
}

# architecture
unless(defined($arch)){
chdir "macros"; 
@macros = glob("*.macros"); 
foreach $choice (@macros) { $choice =~ s/\.macros//; push(@choices,$choice);}
chdir "..";
print "no default build architecture, choices:\n";
$i=0;foreach $choice (@choices) { print "$i $choice\n"; $i++;}
print "macro ? "; $i = <STDIN>; $arch = $choices[$i]; 
print "* you chose : $arch\n";
}

# modules
@modules = @defaultmodules;
$choice = 0;
foreach $key (sort(keys %ENV)) {
	if ($key =~ /TAHOE_BUILD/ && $ENV{$key} =~ /default/) { $choice = 1; }
}
if ($choice != 1) {
print "* default modules : @defaultmodules\n";
print "do want to add optional modules ? (y/n) [n] :"; $choice = <STDIN>;
if ( $choice =~ /y/ ) {
print "\noptional modules:\n";
$i=0;foreach $choice (@optionalmodules) { print "$i $choice\n"; $i++;}
print "modules ? "; $choice = <STDIN>; chomp($choice);
@choices = split(/ +|,/,$choice);
foreach $choice (@choices) { push (@modules,$optionalmodules[$choice]) ;}
print "* you chose : @modules \n";
}
}

print "\n";


open(CONFIG,">$config_file") || die "cannot open file $config_file for writing : $!";
print CONFIG  "# CONNECTION\n$connection\n\n";
print CONFIG  "# PROXY\n$proxy\n\n";
print CONFIG  "# ARCHITECTURE\n$arch\n\n";
print CONFIG  "# MODULES\n@modules\n\n";
print CONFIG  "# EOF";
close(CONFIG);

}

##############################################################################
sub update{
	if ($connection =~ /cvs/) {
		update_cvs();
	} elsif ($connection =~ /http/) {
		update_http();	
	}
	else {
		print "ERROR: unrecognized connection '$connection'\n";	
		exit;
	}
}

##############################################################################
sub update_cvs{
	$time = localtime();
	print "($count) updating: @modules, at $time\n";
	unlink("cvs.log");
	foreach $dir (@modules) {
		if(-d $dir) {
			print "\tupdating $dir";
			system("cd $dir; cvs update -Pd > ../cvs.log 2>&1");
			print " ...done\n";
		} else {
			print "\tchecking out $dir";
			system("cvs -d $username\@$cvsrep checkout $dir > cvs.log 2>&1");
			print " ...done\n";
		}
		# check for failures
		open(IN,"cvs.log");
		@lines = <IN>; $file = "@lines"; close(IN); 
		$errors = ($file =~ /^C /);
                if($errors > 0) {$script_status++;}
	}
}

##############################################################################
sub update_http{
	$time = localtime();
	print "($count) updating: @modules, at $time\n";
	foreach $dir (@modules) {
		print "\tupdating $dir...\n";
		
		# grab new copy
		$curl_cmd = "curl http://tahoe.ca.sandia.gov/download/nightly/$dir.tar.gz --remote-name --connect-timeout 10";
		if ($proxy !~ /NONE/) {
			$curl_cmd = $curl_cmd." --proxy $proxy";
		}
		system("$curl_cmd") == 0
			or die "ERROR: curl failed. Check connection or proxy ($proxy)";

		# move existing directory aside
		if(-d $dir) {

			# parse the date
			($sec, $min, $hour, $mday, $mon, $year, , , ) = localtime;
			$the_date = sprintf("%02d%02d%04d-%02d:%02d:%02d", $mon+1, $mday, $year+1900, $hour, $min, $sec);

			# rename
			if (! -d "saved") {
				system("mkdir saved");
			}
			system("mv $dir saved/$dir.$the_date");
		} 
			
		# unpack
		system("gunzip $dir.tar.gz");
		system("tar xf $dir.tar");
		
		# clean up
		system("rm $dir.tar");
	}
}

##############################################################################
sub build{
	$time = localtime();
# need to sort modules based on dependencies
	@tmp_modules = @modules;
	@modules = sort by_depend @tmp_modules;
	print "($count) building: @modules, at $time\n";
	foreach $dir (@modules) {
		if (-e $dir) {
			chdir $dir;
			if (!(-e "makefile") && (-e "makefile.template")) {
				fillin_makefile();
			}
			if (-e "makefile") {
				print "\tmaking $dir";
				unlink("build.log");
				system("make build > build.log 2>&1");
				# check for errors	
				open(IN,"build.log");
				@lines = <IN>; $file = "@lines"; close(IN); 
				$errors = ($file =~ / error /i);
                		if($errors > 0) 
					{print " ...ERROR\n";$script_status++;}
				else	{print " ...done\n";}
			}
			chdir "..";
		} else {
			print "ERROR : need checkout for $dir\n"; exit;
		}
	}
}

##############################################################################
sub config{
	$time = localtime();
	print "($count) config'ing: @modules, at $time\n";
	foreach $dir (@modules) {
		if (-e $dir) { 
			chdir $dir; 
			if (-e "makefile.template") {
				print "\tcreating makefile in $dir";
				fillin_makefile();
				system("make init > build.log 2>&1");
				print " ...done\n";
			}
		 	chdir "..";
		}
	}

}
##############################################################################
sub clean{
	$time = localtime();
	print "($count) config'ing: @modules, at $time\n";
	foreach $dir (@modules) {
		if (-e $dir) { 
			chdir $dir; 
			if (-e "makefile") {
				print "\tcleaning $dir";
				system("make clean");
				print " ...done\n";
			}
		 	chdir "..";
		}
	}

}
##############################################################################
sub test{
	$time = localtime();
	print "($count) running tests at $time\n";
 	unless(-d "benchmark"){
		print "checking out benchmark\n";
		unlink("cvs.log");
		system("cvs -d $username\@$cvsrep checkout benchmark > cvs.log 2>&1");
 	} else {
		system("cd benchmark; cvs update -Pd > cvs.log 2>&1");
	}
	chdir("benchmark/comparator");
	print("\tbuilding comparator");
	fillin_makefile(); system("make init build > build.log 2>&1");
	print(" ...done\n");
	chdir("..");
	print("\trunning benchmarks");
	system("../tahoe/tahoe -f run.batch > run.out 2>&1");
	print(" ...done\n");
	print("\tcomparing benchmarks");
	system("./comparator/compare -f run.batch > compare.out 2>&1");
	print(" ...done\n");
	open(IN,"compare.summary");
	<IN>; 
	$_ = <IN>; chomp(); s/^\s+//; s/\s+$//; $pass = $_;   
	$_ = <IN>; chomp(); s/^\s+//; s/\s+$//; $fail = $_;   
	print "* $pass $fail, see compare.summary for more details\n";
}
##############################################################################
sub failed{
	$time = localtime();
	die "*-*-*-* process FAILED at $time *-*-*-*\n";
}

##############################################################################
sub usage{
	print "\nusage: tahoe-manager [list of keywords and options]\n";
	print "       update  : updates or checks out modules\n";
	print "       config  : creates makefiles \n";
	print "       build   : builds modules\n";
	print "       test    : runs regression tests\n";
	print "       clean   : cleans modules\n";
	print "       all     : updates, config's and builds \n";
	print "\n ... to build tahoe the first time type \" tahoe-manager all \"\n";
	exit 1;
}

##############################################################################
sub by_depend {
	$filename = "$a/makefile.template";
	$a_on_b = -1;
	if (-e $filename) {
		open(IN,"$filename");
		@lines = <IN>; $afile = "@lines"; 
		close(IN);
		$bdefine = $module2define{$b}; 
 		$a_on_b = ($afile =~ /$bdefine/);
		unless($a_on_b > 0) {$a_on_b = 0;}
	}

	$filename = "$b/makefile.template";
	$b_on_a = -1;
	if (-e $filename) {
		open(IN,"$filename");
		@lines = <IN>; $bfile = "@lines"; 
		close(IN);
		$adefine = $module2define{$a};
	        $b_on_a = ($bfile =~ /$adefine/);
		unless($b_on_a > 0) {$b_on_a = 0;}
	}

	#print " $a $a_on_b $b $b_on_a \n";

        ($a_on_b <=> $b_on_a);
}

##############################################################################
sub fillin_makefile{
	unlink("makefile");
	$path = cwd();
	open(IN,"makefile.template");
	open(OUT,">makefile");
	while (defined($line = <IN>)){
		$line =~ s/HOME_DIR =/HOME_DIR = $path/;
		$line =~ s/ARCH =/ARCH = $arch/;
		foreach $module (@modules) {
			$define = $module2define{$module};
			$line =~ s/\#$define/$define/;
		}
		foreach $syslib (@syslibs) {
			$define = $module2define{$syslib2module{$syslib}};
			$line =~ s/\#$define/$define/;
		}
		print OUT "$line";
 	}
	close(IN);
	close(OUT);
}

##############################################################################
sub my_which{
	my $cmd = shift(@_); 
        $location = "";
        @paths= split(":",$ENV{"PATH"});
        foreach $path (@paths) {
                if(-x "$path/$cmd") { $location = $path; last;}
        }
        return $location;
}
