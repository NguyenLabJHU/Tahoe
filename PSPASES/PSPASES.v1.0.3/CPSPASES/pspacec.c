/*****************************************************************************/
/*                                                                           */
/*   (C) Copyright IBM Corporation, 1997                                     */
/*   (C) Copyright Regents of the University of Minnesota, 1997              */
/*                                                                           */
/*   pspacec.c                                                               */
/*                                                                           */
/*   Written by Mahesh Joshi, U of MN.                                       */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* This code is meant to be used solely for educational, research, and       */
/* benchmarking purposes by non-profit institutions and US government        */
/* agencies only.  Use by any other organization requires prior written      */
/* permission from both IBM Corporation and the University of Minnesota.     */
/* The software may not be sold or redistributed.  One may make copies       */
/* of the software or modify it for their use provided that the copies,      */
/* modified or otherwise, are not sold or distributed, are used under the    */
/* same terms and conditions, and this notice and any part of the source     */
/* code that follows this notice are not separated.                          */
/*                                                                           */
/* As unestablished research software, this code is provided on an           */
/* ``as is'' basis without warranty of any kind, either expressed or         */
/* implied, including but not limited to implied warranties of               */
/* merchantability and fitness for a particular purpose.  IBM does not       */
/* warrant that the functions contained in this software will meet the       */
/* user's requirements or that the operation of its routines will be         */
/* uninterrupted or error-free.  Acceptance and use of this program          */
/* constitutes the user's understanding that he/she will have no recourse    */
/* to IBM for any actual or consequential damages, including, but not        */
/* limited to, lost profits or savings, arising out of the use or inability  */
/* to use these libraries.  Even if the user informs IBM of the possibility  */
/* of such damages, IBM expects the user to accept the risk of any such      */
/* harm, or the user shall not attempt to use these libraries for any        */
/* purpose.                                                                  */
/*                                                                           */
/* The downloading, compiling, or executing any part of this software        */
/* constitutes an implicit agreement to these terms.  These terms and        */
/* conditions are subject to change at any time without prior notice.        */
/*                                                                           */
/*****************************************************************************/
/* $Id: pspacec.c,v 1.1 2004-12-10 20:26:45 paklein Exp $ */
/*****************************************************************************/

#include "pspaces.h"

long check_handle(long,int);

#ifndef FCMATCH
void PSPACEC(long *pspcomm, int *option) {
  Fpspacec(pspcomm,option);
}
#endif

void Fpspacec(long *pspcomm,int *option) 
{

PTRS *ap;
MPI_Comm commin;
int myid,pp;

  ap = (PTRS *)check_handle(*pspcomm,1);
  if(!ap) {
    printf("Invalid PSPASES Communicator supplied to PSPACEC call.\n");
    MPI_Finalize();
    exit(0);
  }

  commin = *(ap->pmcomm);
  MPI_Comm_rank(commin,&myid);
  MPI_Comm_size(commin,&pp);

  switch (*option) {

  case 0:  
    if( ap->howManyNfacts > 0 ) {
      /* Communicator generated by PSPACEY, with at least one referencing
         Nfact. */

      if( ! myid ) {
        printf("[PSPACEC] Cannot free the memory associated with the given\n"); 
        printf("[PSPACEC] PSPASES communicator. It was generated by a call\n");
	printf("[PSPACEC] to PSPACEY and has been used in at least one\n");
        printf("[PSPACEC] numerical factorization. Please free all the %d\n",
	       ap->howManyNfacts);
        printf("[PSPACEC] communicators returned by DPSPACEN calls made so\n");
	printf("[PSPACEC] far with this communicator.\n");
      }

    } else if( (ap->Ylink != NULL) && (ap->howManyNfacts < 0) ) {
      /* Communicator generated by DPSPACEN. */

      ((ap->Ylink)->howManyNfacts) --;
      free(ap->lvals);
      ap = (PTRS *)check_handle(*pspcomm,2);
      free(ap);

    } else {
      /* Communicator generated by PSPACEY with no referencing Nfacts,
	 or by DPSPACEF. */

      if(ap->rowdist) free(ap->rowdist);
      if(ap->order) free(ap->order);
      if(ap->ranmasks) free(ap->ranmasks);

      if(ap->wrkint) free(ap->wrkint);
      if(ap->cinfo) free(ap->cinfo);
      if(ap->painds) free(ap->painds);
      if(ap->paptrs) free(ap->paptrs);
      if(ap->supinds) free(ap->supinds);

      if(ap->lptrs) free(ap->lptrs);
      if(ap->linds) free(ap->linds);
      if(ap->tptrs) free(ap->tptrs);
      if(ap->tinds) free(ap->tinds);
      if(ap->sup) free(ap->sup);
      if(ap->tsind) free(ap->tsind);
      if(ap->lc) free(ap->lc);
      if(ap->iptrs) free(ap->iptrs);
      if(ap->ifopts) free(ap->ifopts);
      if(ap->lvals) free(ap->lvals);
      if(*(ap->pmcomm) != MPI_COMM_NULL) MPI_Comm_free(ap->pmcomm);
      free(ap->pmcomm);

      ap = (PTRS *)check_handle(*pspcomm,2);
      free(ap);

    }

    break;

  case 1:
    if( ap->howManyNfacts < 0 ) {
      /* Communicator was generated by a DPSPACEN or DPSPACEF call. */

      if( ! myid ) {
        printf("[PSPACEC] Option 1 can only be applied to a communicator\n");
        printf("[PSPACEC] generated by a PSPACEY call.\n");
      }

    } else {
      /* Clean storage used up specifically for PSPACEY. This is useful to
         recover some memory before making a call to DPSPACET. This removes 
	 the data required for computing another Numerical factorization 
	 from a Symbolic factorization. So, using this cleanup option before 
	 any DPSPACEN call does not make much sense.
       */

      if(ap->wrkint) free(ap->wrkint);
      ap->wrkint = NULL;
      if(ap->cinfo) free(ap->cinfo);
      ap->cinfo = NULL;
      if(ap->painds) free(ap->painds);
      ap->painds = NULL;
      if(ap->paptrs) free(ap->paptrs);
      ap->paptrs = NULL;
      if(ap->supinds) free(ap->supinds);
      ap->supinds = NULL;

      ap->Ylink = ap;

      if( ! myid ) {
        printf("[PSPACEC] Henceforth, you will not be able to do any more\n"); 
        printf("[PSPACEC] numerical factorizations using this communicator.\n");
      }
    }
    break;

  }

}

long check_handle(long handle,int flag) {
static long handles[MAX_OPEN_PSPCOMMS];
static int init=0;
long retval;
int i;

 if(!init) {
   for(i=0;i<MAX_OPEN_PSPCOMMS;i++) {
     handles[i] = 0; 
   }
   init++;
 }

 switch (flag) {

  case 0:  
      i = 0;
      for(i=0; (i < MAX_OPEN_PSPCOMMS) && handles[i] ; i++ );
      if( i == MAX_OPEN_PSPCOMMS ) {
	retval = -1;
      } else {
        handles[i] = handle;
        retval = i;
      }
      break;

  case 1: 
      if( handle >= MAX_OPEN_PSPCOMMS || handle < 0 )
	retval = 0;
      else 
        retval = handles[handle];
      break;

  case 2: 
      if( handle >= MAX_OPEN_PSPCOMMS || handle < 0 )
        retval = 0;
      else {
        retval = handles[handle];
        handles[handle] = 0;
      }
      break;
 }

 return(retval);
}

