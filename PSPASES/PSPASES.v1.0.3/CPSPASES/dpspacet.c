/*****************************************************************************/
/*                                                                           */
/*   (C) Copyright IBM Corporation, 1997                                     */
/*   (C) Copyright Regents of the University of Minnesota, 1997              */
/*                                                                           */
/*   dpspacet.c                                                              */
/*                                                                           */
/*   Written by Mahesh Joshi, U of MN.                                       */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* This code is meant to be used solely for educational, research, and       */
/* benchmarking purposes by non-profit institutions and US government        */
/* agencies only.  Use by any other organization requires prior written      */
/* permission from both IBM Corporation and the University of Minnesota.     */
/* The software may not be sold or redistributed.  One may make copies       */
/* of the software or modify it for their use provided that the copies,      */
/* modified or otherwise, are not sold or distributed, are used under the    */
/* same terms and conditions, and this notice and any part of the source     */
/* code that follows this notice are not separated.                          */
/*                                                                           */
/* As unestablished research software, this code is provided on an           */
/* ``as is'' basis without warranty of any kind, either expressed or         */
/* implied, including but not limited to implied warranties of               */
/* merchantability and fitness for a particular purpose.  IBM does not       */
/* warrant that the functions contained in this software will meet the       */
/* user's requirements or that the operation of its routines will be         */
/* uninterrupted or error-free.  Acceptance and use of this program          */
/* constitutes the user's understanding that he/she will have no recourse    */
/* to IBM for any actual or consequential damages, including, but not        */
/* limited to, lost profits or savings, arising out of the use or inability  */
/* to use these libraries.  Even if the user informs IBM of the possibility  */
/* of such damages, IBM expects the user to accept the risk of any such      */
/* harm, or the user shall not attempt to use these libraries for any        */
/* purpose.                                                                  */
/*                                                                           */
/* The downloading, compiling, or executing any part of this software        */
/* constitutes an implicit agreement to these terms.  These terms and        */
/* conditions are subject to change at any time without prior notice.        */
/*                                                                           */
/*****************************************************************************/
/* $Id: dpspacet.c,v 1.1 2004-12-10 20:26:45 paklein Exp $ */
/*****************************************************************************/

#include "pspaces.h"

#ifndef FCMATCH
void DPSPACET(int *rowdistb,int *pnrhs,double *b,int *pldb,double *x,
                  int *pldx,int *options,long *pspcomm,MPI_Comm *pcomm) {
  Fdpspacet(rowdistb,pnrhs,b,pldb,x,pldx,options,pspcomm,pcomm);
}
#endif

void Fdpspacet(int *rowdistb,int *pnrhs,double *b,int *pldb,double *x,
                   int *pldx,int *options,long *pspcomm,MPI_Comm *pcomm)
{
int N,ldb,ldx,myid,pp,diff,i,j,nrhs;
PTRS *ap;
int *rowdista,*Aorder,*BXorder,*ranmasks,*lptrs,*linds,*tptrs,*tinds;
int *sup,*tsind;
int *lc,*iptrs,*ifopts,*temparr1,*temparr2,ntemp;
int k,howManyNfacts;
double *lvals;
double sanity,totsan;
MPI_Comm comm,commin;

  commin = *pcomm;
  nrhs = *pnrhs;
  ldb = *pldb;
  ldx = *pldx;

  MPI_Comm_rank(commin,&myid);
  MPI_Comm_size(commin,&pp);

  ap = (PTRS *)check_handle(*pspcomm,1);
  if(!ap) {
    if(!myid)
      printf("[DPSPACET] Invalid PSPASES communicator.\n");
    MPI_Barrier(commin);
    MPI_Abort(commin,0);
  }

  howManyNfacts = ap->howManyNfacts;

  if(howManyNfacts >= 0) {
    if(!myid) {
      printf("[DPSPACET] The PSPASES communicator supplied to DPSPACET must\n");
      printf("[DPSPACET] be generated by a DPSPACEN or a DPSPACEF call. You\n");
      printf("[DPSPACET] seem to have supplied a communicator that was\n");
      printf("[DPSPACET] generated by a PSPACEY call.\n");
    }
    MPI_Barrier(commin);
    MPI_Abort(commin,0);
  }

  rowdista = ap->rowdist;
  Aorder = ap->order;
  ranmasks = ap->ranmasks;
  lptrs = ap->lptrs;
  linds = ap->linds;
  lvals = ap->lvals;
  tptrs = ap->tptrs;
  tinds = ap->tinds;
  sup = ap->sup;
  tsind = ap->tsind;
  lc = ap->lc;
  iptrs = ap->iptrs;
  ifopts = ap->ifopts;
  comm = *(ap->pmcomm);

  MPI_Comm_compare(comm,commin,&diff);
  if(diff == MPI_UNEQUAL || diff == MPI_SIMILAR) {
    if(!myid) {
      printf("[DPSPACET] Corresponding call to DPSPACEF or DPSPACEN hads\n");
      printf("[DPSPACET] different MPI group.\n");
    }
    MPI_Barrier(commin);
    MPI_Abort(commin,0);
  }

  MPI_Comm_rank(comm,&myid);
  MPI_Comm_size(comm,&pp);

  if(!(lvals && tsind)) {
    printf("[DPSPACET] Cannot proceed with DPSPACET.\n");
    printf("[DPSPACET] Required data structures not available.\n");
    printf("[DPSPACET] Possible absence of a DPSPACEN or DPSPACEF\n");
    printf("[DPSPACET] call prior to this.\n");
    MPI_Abort(comm,0);
  }

  ntemp = pp+1+1+T_NOPTS;
  if(!(temparr1 = (int *)malloc(ntemp*sizeof(int)))) {
    printf("[dpspacet.c:1] memory allocation error\n");
    MPI_Abort(comm,0);
  }
  for(i=0;i<pp+1;i++) temparr1[i] = rowdistb[i];
  temparr1[i++] = nrhs;
  for(j=0;j<T_NOPTS;j++) temparr1[j+i] = options[j];
  if(!myid) {
    if(!(temparr2 = (int *)malloc(ntemp*sizeof(int)))) {
      printf("[dpspacet.c:2] memory allocation error\n");
      MPI_Abort(comm,0);
    }
  }
  MPI_Reduce(temparr1,temparr2,ntemp,MPI_INT,MPI_BXOR,0,comm);
  if(!myid) {
    for(i=0;i<ntemp;i++) {
      if(temparr2[i]) {
        printf("[DPSPACET] Global parameters not matching on all processors!\n");
        if(i<pp+1) 
          printf("[DPSPACET] Check rowdistb[%d] !\n",i);
        else {
          if(i==pp+1) printf("[DPSPACET] Check nrhs !\n");
          else printf("[DPSPACET] Check options[%d] !\n",i-(pp+2));
        }
        MPI_Abort(comm,0);
      }
    }
    free(temparr2);
  }
  MPI_Barrier(comm);
  free(temparr1);

  N = rowdistb[pp];

  if(ifopts[0]!=N) {
    if(!myid) {
      printf("[DPSPACET] Mismatch between the order of the factored matrix\n");
      printf("[DPSPACET] and N implied by the rowdistb parameter.\n");
    }
    MPI_Barrier(comm);
    MPI_Abort(comm,0);
  }

  diff = 0;
  for(i=0;i<=pp;i++) {
    if(rowdista[i]!=rowdistb[i]) {
      diff=1;
      break;
    }
  }

  if(diff) {

    i = pp;
    if(!myid) i+=N;
    if(!(temparr1 = (int *)malloc(i*sizeof(int)))) {
      printf("[dpspacet.c:3] memory allocation error\n");
      MPI_Abort(comm,0);
    }

    for(i=0;i<pp;i++) temparr1[i] = rowdista[i+1]-rowdista[i];

    MPI_Gatherv(Aorder,temparr1[myid],MPI_INT,
                &(temparr1[pp]),temparr1,rowdista,MPI_INT,0,comm);

    for(i=0;i<pp;i++) temparr1[i] = rowdistb[i+1]-rowdistb[i];

    if(!(BXorder = (int *)malloc(temparr1[myid]*sizeof(int)))) {
      printf("[dpspacet.c:4] memory allocation error\n");
      MPI_Abort(comm,0);
    }

    MPI_Scatterv(&(temparr1[pp]),temparr1,rowdistb,MPI_INT,
                 BXorder,temparr1[myid],MPI_INT,0,comm);

    free(temparr1);

  } else {
    BXorder = Aorder;
  }

  trisolve(&N,rowdistb,BXorder,lptrs,linds,lvals,tptrs,tinds,
           sup,tsind,lc,iptrs,ifopts,pnrhs,options,b,pldb,
           x,pldx,ranmasks,&comm);

  if( diff ) free(BXorder);

/*
sanity = 0.0;
for(j=0;j<nrhs;j++) {
 k = j*ldx;
 for(i=k;i<k+rowdistb[myid+1]-rowdistb[myid];i++) sanity = sanity+x[i];
}
MPI_Reduce(&sanity,&totsan,1,MPI_DOUBLE,MPI_SUM,0,comm);

if(!myid) {
  printf(" X Sanity = %20.15le\n",totsan/(double)(N*nrhs));
}
*/

}
