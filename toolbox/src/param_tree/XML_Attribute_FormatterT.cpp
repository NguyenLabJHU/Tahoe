/* $Id: XML_Attribute_FormatterT.cpp,v 1.1 2002-11-18 09:57:29 paklein Exp $ */
#include "XML_Attribute_FormatterT.h"
#include "ParameterListT.h"
#include "ParameterT.h"
#include "BinaryTreeT.h"
#include "LinkedListT.h"

/* attribute type names */
static const char* a_dtype_names[4] = {"integer", "float", "string"};
static const char* a_dtype(ValueT::TypeT t)
{
	switch (t)
	{
		case ValueT::Integer:
			return a_dtype_names[0];
			break;
		case ValueT::Double:
			return a_dtype_names[1];
			break;
		default:
			return a_dtype_names[2];
	}
};

static const char* type_names[4] = {"Integer", "Double", "String", "Enumeration"};
static const char* TypeName(ValueT::TypeT t)
{
	switch (t)
	{
		case ValueT::Integer:
			return type_names[0];
			break;
		case ValueT::Double:
			return type_names[1];
			break;
		case ValueT::String:
			return type_names[2];
			break;
		case ValueT::Enumeration:
			return type_names[3];
			break;	
	
		default:
			return NULL;
	}
};

static const char* occur_char_list[4] = {"", "?", "+", "*"};
static const char* occur_char(ParameterListT::OccurrenceT o)
{
	switch (o)
	{
		case ParameterListT::ZeroOrOnce:
			return occur_char_list[1];
			break;
		case ParameterListT::OnePlus:
			return occur_char_list[2];
			break;
		case ParameterListT::Any:
			return occur_char_list[3];
			break;		
		default:
			return occur_char_list[0];
	}
};

using namespace Tahoe;

XML_Attribute_FormatterT::XML_Attribute_FormatterT(void):
	fDocumentRoot("parameter_list")
{

}

void XML_Attribute_FormatterT::SetDTD(const StringT& dtd_path, const StringT& doc_root)
{
	fDTD = dtd_path;
	fDocumentRoot = doc_root;
}

bool XML_Attribute_FormatterT::InitParameterFile(ostream& out) const
{
	/* write XML header */
	out << "<?xml version='1.0' encoding='US-ASCII' standalone='no' ?>" << '\n';

	/* DTD is set */
	if (fDTD.StringLength() > 0)
		out << "<!DOCTYPE " << fDocumentRoot << " SYSTEM '" << fDTD << "'>" << '\n';
	
	out.flush();
	return true;
}

bool XML_Attribute_FormatterT::WriteParameterList(ostream& out, const ParameterListT& list) const
{
	/* list tag name */
	const StringT& tag = list.Name();

	/* open tag */
	out << '\n' << Tab() << "<" << tag;
	
	/* description */
	if (list.Description().StringLength() > 0)
		out << " description='" << list.Description() << "'";
	
	/* plain parameters as attributes */
	const ArrayT<ParameterT>& params = list.Parameters();
	for (int i = 0; i < params.Length(); i++)
		out << " " << params[i].Name() << "='" << params[i] << "'";

	/* non-empty */
	if (list.Lists().Length() > 0)
	{
		/* close tag */
		out << ">";
		TabOut();
	
		/* nested paramater lists */
		const ArrayT<ParameterListT>& nested_lists = list.Lists();
		for (int i = 0; i < nested_lists.Length(); i++)
			WriteParameterList(out, nested_lists[i]);

		TabIn();
		out << '\n' << Tab() << "</" << tag << ">" << '\n';
	}
	else /* empty element */
		out << "/>";

	out.flush();
	return true;
}

bool XML_Attribute_FormatterT::CloseParameterFile(ostream& out) const
{
	/* add extra newline and flush */
	out << endl;
	return true;
}

bool XML_Attribute_FormatterT::InitDescriptionFile(ostream& out) const
{
	out << "<?xml version='1.0' encoding='US-ASCII' ?>" << '\n';
	out << '\n'; 
	out << "<!--Generated by Tahoe::XML_Attribute_FormatterT $Revision: 1.1 $-->" << '\n';
	return true;
}

bool XML_Attribute_FormatterT::CloseDescriptionFile(ostream& out) const
{
	/* add extra newline and flush */
	out << endl;
	return true;
}

/* write the data description */
bool XML_Attribute_FormatterT::WriteDescription(ostream& out, const ParameterListT& list) const
{
	BinaryTreeT<StringT> tags;
	return DoWriteDescription(out, list, tags);
}

/*************************************************************************
 * Private
 *************************************************************************/

/* write the data description */
bool XML_Attribute_FormatterT::DoWriteDescription(ostream& out, const ParameterListT& list, BinaryTreeT<StringT>& tags) const
{
	/* check tag name */
	if (!tags.InsertUnique(list.Name()))
	{
		cout << "\n XML_Attribute_FormatterT::DoWriteDescription: skipping repeated tag: "
		     << list.Name() << endl;
		return false;
	}

	/* open description */
	out << "\n<!ELEMENT " << list.Name();
	
	/* child  */
	const ArrayT<ParameterListT>& nested_lists = list.Lists();
	const ArrayT<StringT>& references = list.References();
	if (nested_lists.Length() > 0 || references.Length() > 0)
	{
		/* open */
		out << " (";
		
		bool first = true;
		
		/* nested lists */
		const ArrayT<ParameterListT::OccurrenceT>& list_occur = list.ListOccurrences();
		for (int i = 0; i < nested_lists.Length(); i++)
		{
			if (first) first = false;
			else out << ',';
			out << "\n\t" << nested_lists[i].Name() << occur_char(list_occur[i]);		
		}

		/* references */
		const ArrayT<ParameterListT::OccurrenceT>& ref_occur = list.ReferenceOccurrences();
		for (int i = 0; i < references.Length(); i++)
		{
			if (first) first = false;
			else out << ',';
			out << "\n\t" << references[i] << occur_char(ref_occur[i]);		
		}

		/* close */
		out << "\t)\n";
	}
	else /* empty element */
		out << " EMPTY";
	
	/* close description */
	out << ">\n";

	/* write parameters as attributes */
	const ArrayT<ParameterT>& params = list.Parameters();
	if (params.Length() > 0 || list.Description().StringLength() > 0)
	{
		/* get max attribute name length */
		int name_width = 0;
		if (list.Description().StringLength() > 0) name_width = strlen("description");
		for (int i = 0; i < params.Length(); i++)
		{
			int len = params[i].Name().StringLength();
			name_width = (len > name_width) ? len : name_width;
		}
		name_width += 1; /* extra space */

		/* open attribute list */
		out << "<!ATTLIST " << list.Name();
	
		/* description */
		if (list.Description().StringLength() > 0)
			out << "\n" << setw(name_width) << "description" << " CDATA #FIXED '" << list.Description() << "'";
	
		const ArrayT<ParameterListT::OccurrenceT>& param_occur = list.ParameterOccurrences();
		for (int i = 0; i < params.Length(); i++)
		{
			out << "\n" << setw(name_width) << params[i].Name();
			
			/* attribute is an enumeration */
			if (params[i].Type() == ValueT::Enumeration)
			{
				LinkedListT<LimitT>& limits = params[i].Limits();
				if (!limits.IsEmpty())
				{
					out << " (";
					
					bool first = true;
					LimitT limit;
					limits.Top();
					while (limits.Next(limit)) /* assume all are LimitT::Only */
					{
						if (first) first = false;
						else out << '|';
						out << limit;
					}

					out << ")";
				}
			}
			else /* all other attributes */
			{
				out << " CDATA";
			}

			/* default value */
			const ValueT* def = params[i].Default();
			if (def) 
				out << " '" << (*def) << "'";
			else
			{
				switch (param_occur[i])
				{
					case ParameterListT::ZeroOrOnce:
						out << " #IMPLIED";
						break;

					case ParameterListT::Once:
						out << " #REQUIRED";
						break;

					case ParameterListT::OnePlus:
						cout << "\n XML_Attribute_FormatterT: occurrence of " << params[i].Name() << " changed from OnePlus to Once" << endl;
						out << " #REQUIRED";
						break;

					case ParameterListT::Any:
						cout << "\n XML_Attribute_FormatterT: occurrence of " << params[i].Name() << " changed from Any to ZeroOrOnce" << endl;
						out << " #IMPLIED";
						break;		
						
					default:		
						cout << "\n XML_Attribute_FormatterT: occurrence of " << params[i].Name() << " changed to ZeroOrOnce" << endl;
						out << " #IMPLIED";
						break;		
				}
			}
		}
		
		/* attribute data types */
		if (params.Length() > 0)
		{
			/* open line */
			out << "\n" << setw(name_width) << "a-dtype" << " NMTOKENS 'description string";
			for (int i = 0; i < params.Length(); i++)
				if (params[i].Type() != ValueT::Enumeration)
					out << " " << params[i].Name() << " " << a_dtype(params[i].Type());

			/* close line */
			out << "'";
		}

		/* close attributes */
		out << "\n>";
	}

	/* recursively process nested_lists */
	bool nested_lists_OK = true;
	for (int i = 0; i < nested_lists.Length(); i++)
		nested_lists_OK = nested_lists_OK && DoWriteDescription(out, nested_lists[i], tags);

	/* return */
	return nested_lists_OK;
}
