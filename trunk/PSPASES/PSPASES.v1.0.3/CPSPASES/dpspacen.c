/*****************************************************************************/
/*                                                                           */
/*   (C) Copyright IBM Corporation, 1997                                     */
/*   (C) Copyright Regents of the University of Minnesota, 1997              */
/*                                                                           */
/*   dpspacen.c                                                              */
/*                                                                           */
/*   Written by Mahesh Joshi, U of MN.                                       */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* This code is meant to be used solely for educational, research, and       */
/* benchmarking purposes by non-profit institutions and US government        */
/* agencies only.  Use by any other organization requires prior written      */
/* permission from both IBM Corporation and the University of Minnesota.     */
/* The software may not be sold or redistributed.  One may make copies       */
/* of the software or modify it for their use provided that the copies,      */
/* modified or otherwise, are not sold or distributed, are used under the    */
/* same terms and conditions, and this notice and any part of the source     */
/* code that follows this notice are not separated.                          */
/*                                                                           */
/* As unestablished research software, this code is provided on an           */
/* ``as is'' basis without warranty of any kind, either expressed or         */
/* implied, including but not limited to implied warranties of               */
/* merchantability and fitness for a particular purpose.  IBM does not       */
/* warrant that the functions contained in this software will meet the       */
/* user's requirements or that the operation of its routines will be         */
/* uninterrupted or error-free.  Acceptance and use of this program          */
/* constitutes the user's understanding that he/she will have no recourse    */
/* to IBM for any actual or consequential damages, including, but not        */
/* limited to, lost profits or savings, arising out of the use or inability  */
/* to use these libraries.  Even if the user informs IBM of the possibility  */
/* of such damages, IBM expects the user to accept the risk of any such      */
/* harm, or the user shall not attempt to use these libraries for any        */
/* purpose.                                                                  */
/*                                                                           */
/* The downloading, compiling, or executing any part of this software        */
/* constitutes an implicit agreement to these terms.  These terms and        */
/* conditions are subject to change at any time without prior notice.        */
/*                                                                           */
/*****************************************************************************/
/* $Id: dpspacen.c,v 1.1 2004-12-10 20:26:44 paklein Exp $ */
/*****************************************************************************/

#include "pspaces.h"

#ifndef FCMATCH
void DPSPACEN(int *rowdista,int *aptrs,int *ainds,double *avals,
              long *pspcommin,long *pspcommout,MPI_Comm *pcomm) {
  Fdpspacen(rowdista,aptrs,ainds,avals,pspcommin,pspcommout,pcomm);
}
#endif

void Fdpspacen(int *rowdista,int *aptrs,int *ainds,double *avals,
               long *pspcommin,long *pspcommout,MPI_Comm *pcomm)
{
int N,myid,pp,i,j,k,diff,dd,lgblk,wsolvesize,ns,supindsize,myidh,myidv;
int supsize,nnz,lspace,wsize0,wsize1,ibuflen,dbuflen,iwspace,IWN,mynnodes;
int node,stakptr,nptr;
int supindsptr,info,root,blk,maxnzpercol,pasize;
PTRS *ap,*apn,*yLink;
int *rowdist,*order,*ranmasks,*wrkint,*cinfo,*painds,*paptrs;
int *lptrs,*linds,*tptrs,*tinds,*sup,*tsind,*supinds;
int *lc,*iptrs,*ifopts,*temparr1,*temparr2,ntemp;
double *pavals,*lvals,dfopts[7];
MPI_Comm comm,commin;
FILE *fp;
int lcsize,howManyNfacts;
double sanity,totsan;

  commin = *pcomm;

  MPI_Comm_rank(commin,&myid);
  MPI_Comm_size(commin,&pp);

  ap = (PTRS *)check_handle(*pspcommin,1);
  if(!ap) {
    if(!myid)
      printf("[DPSPACEN] Invalid PSPASES communicator.\n");
    MPI_Barrier(commin);
    MPI_Abort(commin,0);
  }

  yLink = ap->Ylink;
  howManyNfacts = ap->howManyNfacts;

  if(yLink != NULL || howManyNfacts < 0) {
    if(!myid) {
      printf("[DPSPACEN] The PSPASES communicator supplied to DPSPACEN must\n");
      printf("[DPSPACEN] be a valid PSPACEY-generated communicator (it\n");
      printf("[DPSPACEN] should have been generated by PSPACEY, and should\n");
      printf("[DPSPACEN] not have been cleaned up later by a PSPACEC call\n");
      printf("[DPSPACEN] with option 1).\n");
    }
    MPI_Barrier(commin);
    MPI_Abort(commin,0);
  }

  rowdist = ap->rowdist;
  order = ap->order;
  ranmasks = ap->ranmasks;

  wrkint = ap->wrkint;
  cinfo = ap->cinfo;
  painds = ap->painds;
  paptrs = ap->paptrs;
  supinds = ap->supinds;

  lptrs = ap->lptrs;
  linds = ap->linds;
  tptrs = ap->tptrs;
  tinds = ap->tinds;
  sup = ap->sup;
  tsind = ap->tsind;
  lc = ap->lc;
  iptrs = ap->iptrs;
  ifopts = ap->ifopts;
  comm = *(ap->pmcomm);

  MPI_Comm_compare(comm,commin,&diff);
  if(diff == MPI_UNEQUAL || diff == MPI_SIMILAR) {
    if(!myid) 
      printf("[DPSPACEN] Corresponding call to PSPACEY had different MPI group.\n");
    MPI_Barrier(commin);
    MPI_Abort(commin,0);
  }

  MPI_Comm_rank(comm,&myid);
  MPI_Comm_size(comm,&pp);

  if(!(wrkint && cinfo && painds && paptrs && supinds)) {
    printf("[DPSPACEN] Cannot proceed with DPSPACEN.\n"); 
    printf("[DPSPACEN] Required data structures not available.\n");
    printf("[DPSPACEN] Possible presence of a PSPACEC call prior to this call.\n");
    MPI_Abort(comm,0);
  }

  N = rowdista[pp];

  if(ifopts[0]!=N) {
    if(!myid) 
      printf("[DPSPACEN] N does not match to the order of symbolically factored matrix.\n");
    MPI_Barrier(comm);
    MPI_Abort(comm,0);
  }

  for(i=0;i<pp+1;i++) {
    if(rowdist[i] != rowdista[i]) {
      printf("[DPSPACEN] Error : rowdista does not match to that of PSPACEY call.\n");
      MPI_Abort(comm,0);
    }
  }

  dd         = ifopts[1];
  lgblk      = ifopts[2];
  wsolvesize = ifopts[3];
  ns         = ifopts[4];
  supindsize = ifopts[5];
  myid       = ifopts[6];
  myidh      = ifopts[7];
  myidv      = ifopts[8];
  supsize    = ifopts[9];
  nnz        = ifopts[10];
  lspace     = ifopts[11];
  wsize0     = ifopts[12];
  wsize1     = ifopts[13];
  ibuflen    = ifopts[14];
  dbuflen    = ifopts[15];
  iwspace    = ifopts[16];
  node       = ifopts[17];
  stakptr    = ifopts[18];
  nptr       = ifopts[19];
  IWN        = ifopts[20];
  maxnzpercol= ifopts[21];
  pasize     = ifopts[22];

  mynnodes = rowdista[myid+1]-rowdista[myid];

  if(!(pavals = (double *)malloc(pasize*sizeof(double)))) {
    printf("[dpspacen.c:1] memory allocation error\n");
    MPI_Abort(comm,0);
  }

  moveav(&N,&dd,&pp,&lgblk,&myid,rowdista,&mynnodes,
         order,aptrs,ainds,avals,pavals,wrkint,
         &maxnzpercol,ranmasks,&comm);

  supindsptr = supindsize+1;

  if(!(lvals = (double *)malloc(lspace*sizeof(double)))) {
    printf("[dpspacen.c:2] memory allocation error\n");
    MPI_Abort(comm,0);
  }

  for(i=0;i<7;i++) dfopts[i] = 0.0;
  for(i=0;i<5;i++) ifopts[i] = 0;

  root = N-1;
  blk = 1<<lgblk;
  info = 0;

  pparfact1(&N,paptrs,painds,pavals,lptrs,linds,lvals,tptrs,tinds,sup,
         &(wrkint[IWN]),&(wrkint[IWN+N]),&root,&dd,&lgblk,&blk,&myid,
         cinfo,supinds,&supindsptr,dfopts,ifopts,&(wrkint[IWN+N+N]),
         &wsize0,&wsize1,&ibuflen,&dbuflen,&iwspace,&node,&stakptr,&nptr,
         lc,iptrs,&info,&comm);

  if(info) {
    printf("Non Positive Definite Matrix found!\n");
    MPI_Abort(comm,0);
  }

  free(pavals);

  ifopts[0] = N;
  ifopts[1] = dd;
  ifopts[2] = lgblk;
  ifopts[3] = wsolvesize;
  ifopts[4] = ns;

  if(!(apn = (PTRS *)malloc(sizeof(PTRS)))) {
    printf("[dpspacen.c:3] Memory allocation error.\n");
    MPI_Abort(comm,0);
  }

  apn->Ylink = ap;
  apn->howManyNfacts = -1;

  (ap->howManyNfacts) ++;

  apn->rowdist = ap->rowdist;
  apn->order = ap->order;
  apn->ranmasks = ap->ranmasks;

  apn->wrkint = NULL;
  apn->cinfo = NULL;
  apn->painds = NULL;
  apn->paptrs = NULL;
  apn->supinds = NULL;

  apn->lptrs = ap->lptrs;
  apn->linds = ap->linds;
  apn->tptrs = ap->tptrs;
  apn->tinds = ap->tinds;
  apn->sup = ap->sup;
  apn->tsind = ap->tsind;
  apn->lc = ap->lc;
  apn->iptrs = ap->iptrs;
  apn->ifopts = ap->ifopts;

  apn->lvals = lvals;

  apn->pmcomm = ap->pmcomm;
  
  *pspcommout = check_handle((long)apn,0);
  if( *pspcommout < 0 ) {
    if(!myid) {
      printf("Unable to create new PSPASES communicator, all %d slots\n",
	     MAX_OPEN_PSPCOMMS);
      printf("are taken up. Please free some of those communicators using\n");
      printf("PSPACEC.\n");
    }
    MPI_Barrier(comm);
    MPI_Abort(comm,0);
  }

/*
compmysan(&sanity,&N,lptrs,lvals,linds,cinfo);

MPI_Reduce(&sanity,&totsan,1,MPI_DOUBLE,MPI_SUM,0,comm);
if(!myid) {
  printf(" L Sanity = %20.15le\n",totsan/(double)N);
}
*/

}
