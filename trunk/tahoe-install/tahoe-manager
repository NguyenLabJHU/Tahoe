#!/usr/bin/perl -w
# $Id: tahoe-manager,v 1.20 2005-03-04 10:25:16 paklein Exp $
#------------------------------------------------------------------------------
# tahoe-manager: 
#    a PERL script to checkout, configure, build and run regression tests
#    for TAHOE
# written by: 
#    Reese Jones (rjones@sandia.gov) and Patrick Klein (paklein@sandia.gov)
#------------------------------------------------------------------------------

use Cwd; # $home = cwd();

# prefix on macros in the makefiles
%module2define = qw(
expat	EXPAT_
toolbox	TB_
tahoe	TAHOE_
macros	NODEFINE
spooles SPOOLES_
spoolesMPI SPOOLESMPI_
metis   METIS_
aztec   AZ_
f2c	    F2C_
blas	BLAS_
access	AX_
development DEV_
Sierra SIERRA_
qhull  QHULL_
);

# location of module on the server
%module2repo = qw(
expat /cvs/protected/tahoe
toolbox /cvs/protected/tahoe
tahoe /cvs/protected/tahoe
macros /cvs/protected/tahoe
spooles /cvs/protected/tahoe
spoolesMPI /cvs/protected/tahoe
metis /cvs/protected/tahoe
aztec /cvs/protected/tahoe
f2c /cvs/protected/tahoe
blas /cvs/protected/tahoe
access /cvs/protected/tahoe
development /cvs/private/tahoe
Sierra /cvs/private/tahoe
qhull /cvs/private/tahoe
benchmark_XML /cvs/protected/tahoe
);

# modules in the UP_TO_DATE macro
%up_to_date_modules = qw(
development 1
Sierra 1
);

# modules available via http
%http_modules = qw(
macros 1
expat 1
toolbox 1
tahoe 1
benchmark_XML 1
metis 1
spooles 1
spoolesMPI 1
spoolesMT 1
);

# minimum required installation
@defaultmodules = ("macros","expat","toolbox","tahoe");

%syslib2module = qw(
ACCESS	access
);

%module2syslib = qw(
access ACCESS
);

%connect2command = qw(
cvs     cvs
http	curl
);

# tahoe server
$ tahoe = "tahoe.ca.sandia.gov"; 

# default configuration file
$config_file = "./.tahoe_config";

# initialization
initialize();

# loop through arguments and options
$script_status = 0;
if (@ARGV < 1) {usage(); exit 0;}
ARG: while (@ARGV) {
	OPT: for (shift@ARGV) {
		$count = @ARGV;
		if ($script_status > 0 )   { failed();}
		if (/^u|update/i)          { update(); next ARG; }
		if (/^co|config/i)          { config(); next ARG; }
		if (/^i|init/i)            { init(); next ARG; }
		if (/^b|build/i)           { build(); next ARG; }
		if (/^cl|clean/i)          { clean(); next ARG; }
		if (/^t|test/i)            { test(); next ARG; }
#		if (/^a|all/i)             { update(); init(); build(); next ARG; }
		if (/^u|usage|help|^h/i)   { usage();}
		print "ERROR: unknown option: $_ \n"; usage();
	}
}

exit 0;

###############################################################################
sub initialize{

# classify modules
my %tmp = %module2define;
foreach my $key (@defaultmodules) {
	delete $tmp{$key};
}
@optionalmodules = keys (%tmp);

# search for system libs 
foreach my $key (sort(keys %ENV)) {
	foreach my $lib (keys %syslib2module) {
		if ($key =~ /$lib/ ) { 
			my $loc = $ENV{$key};
			print "* found system library $lib \@ $loc \n"; 
			push(@syslibs,$lib);
		}
	}
}

# configuration file
if(-e "$config_file") { read_config();}
else                  { write_default_config();}

print ">   tahoe name: $tahoe_name\n";
print ">   connection: $connection\n";
if ($proxy !~ /NONE/) {
	print ">        proxy: $proxy\n";
}
print "> architecture: $arch \n"; 

# check connection method
#open(WHICH, "which $connect2command{$connection} |");
if (my_which($connect2command{$connection}) =~ "") {
	print "ERROR: command \"$connect2command{$connection}\" not found\n";
	if ($connection =~ /http/) {
		print "ERROR: curl is available from http://curl.haxx.se/\n";
	}
 	exit;
}

# check cvs settings
if ($connection =~ /cvs/) {
	my $cvs_OK = 0;
	foreach my $key (sort(keys %ENV)) {
		if ($key =~ /CVS_RSH/ && $ENV{$key} =~ /ssh/) { $cvs_OK = 1; }
	}
	if ($cvs_OK != 1) {
		print "ERROR: CVS_RSH must be set to ssh\n";
		exit;
	}
}
}

##############################################################################
sub config {
	@config_options = ("add optional modules", "remove optional modules", "configure options within modules");
	print "\nconfiguration options:\n";
	my $i = 0;
	foreach my $option (@config_options) {
		print "$i $option\n"; 
		$i++
	}
	print "\nchoice: ";
	my $choice = <STDIN>;
	if ($choice =~ /0/) {
		add_optional_modules();
		write_config();
	} elsif ($choice =~ /1/) {
		remove_optional_modules();
		write_config();
	} else {
		module_config();
	}
	
	# rewrite configuration file
	write_config();
}

##############################################################################
sub read_config{
print "* reading config file $config_file\n";
open(CONFIG,$config_file) || die "cannot open file $config_file for reading : $!";
my $type = "UNKNOWN";
while(<CONFIG>) {
	s/^\s+//; s/\s+$//; @list = split(/ +/);
 	if (defined($list[0])){
        	if (/^\#/ ){ 
			if ($type  =~ /CONNECTION/) {$connection = $tmp_list[0];}
			elsif ($type =~ /TAHOE_LOGIN/) { $tahoe_name = $tmp_list[0]; }
			elsif  ($type  =~ /PROXY/){$proxy = $tmp_list[0];}
			elsif  ($type  =~ /ARCH/){$arch = $tmp_list[0];}
 			elsif  ($type  =~ /MODU/){@modules = @tmp_list;}
 			$type = $list[1]; @tmp_list =();
 		} 
 		else { push(@tmp_list,@list);}
 	}
}
close(CONFIG);

# need to make sure the core modules exist
foreach my $core (@defaultmodules) {
	my $found = 0;
	foreach $module (@modules) {
 		if($module =~ $core) { $found = 1;}
	}
	unless($found){
		print "* adding : $core to modules\n";
 		push(@modules,$core);
 	}
}
}

##############################################################################
sub write_default_config{
print "* creating default config file $config_file\n";

# look for environmental settings
$tahoe_name = "nobody";
foreach my $key (sort(keys %ENV)) {
	my $value =  $ENV{$key};
	if ($key =~ /TAHOE_CONNECT/ ) {
		print "* found environmental var : $key = $value\n";
		$connection = $value;}
	if ($key =~ /TAHOE_ARCH/ ) { 
		print "* found environmental var : $key = $value\n";
		$arch = $value;}
	if ($key =~ /CVS_RSH/) { 
		print "* found CVS_RSH env var, using cvs connection\n"; 
		$connection = "cvs"; }
	
	# get user name on local machine
	if ($key =~ /^USER$/) {
		$tahoe_name = $value;
		# the builtin function getlogin() sometimes returns the wrong name
	}
}

# connection type
$proxy = "NONE";
unless(defined($connection)) { 
	@connections = ("cvs", "http");
	my $i=0;
	foreach my $choice (@connections) { 
		print "$i $choice\n"; 
		$i++; 
	}
	print "connection type [0]: ";
	$i = <STDIN>; 
	chomp($i);
	if (length($i) == 0) { # default
		$i = 0;
	}
	$connection = $connections[$i];
	if ($connection =~ /http/) { # ask for proxy
		print "http proxy (proxyhost:port) [NONE]:";
		$proxy = <STDIN>;
		chomp($proxy);
		if (length($proxy) == 0) { # default
			$proxy = "NONE";
		}
	}
	else {
        my $cvs_OK = 0;
        foreach $key (sort(keys %ENV)) {
                if ($key =~ /CVS_RSH/ && $ENV{$key} =~ /ssh/) { $cvs_OK = 1; }
        }
        if ($cvs_OK != 1) {
                print "ERROR: CVS_RSH must be set to ssh\n";
                exit;
        }
	}
}

# Tahoe server login name
if ($connection =~ /cvs/) {
	print "Tahoe server username [$tahoe_name]: ";
	my $name = <STDIN>; chomp($name);
	if (length($name) > 0) {
		$tahoe_name = $name;
	}
}

# get macros module
unless(-d "macros") {
	if ($connection =~ /cvs/) {
		print "checking out macros...";
		unlink("cvs.log");
		my $repo = $module2repo{"macros"};
		system("cvs -d $tahoe_name\@$tahoe:$repo checkout macros > cvs.log 2>&1");
		print " ok\n";
	} elsif ($connection =~ /http/) {
	
		# grab new copy
		my $curl_cmd = "curl http://tahoe.ca.sandia.gov/download/nightly/macros.tar.gz --remote-name --connect-timeout 10";
		if ($proxy !~ /NONE/) {
			$curl_cmd = $curl_cmd." --proxy $proxy";
		}
		system("$curl_cmd") == 0
			or die "ERROR: curl failed. Check connection or proxy ($proxy)";

		# unpack
		system("gunzip macros.tar.gz");
		system("tar xf macros.tar");
		system("rm macros.tar");
	}
	else {
		print "ERROR: unrecognized connection '$connection'\n";	
		exit;
	}
}

# architecture
unless(defined($arch))	{
	chdir "macros"; 
	my @macros = glob("*.macros"); 
	foreach my $choice (@macros) { 
		$choice =~ s/\.macros//; 
		push(@choices,$choice);
	}
	chdir "..";
	print "no default build architecture, choices (".scalar(@choices)."):\n";
	my $i=0;	
	print_in_columns(3, @choices);
	print "\nmacro number: "; 
	$i = <STDIN>; 
	$arch = $choices[$i]; 
	print "* you chose : $arch\n";
}

# modules
@modules = @defaultmodules;
my $choice = 0;
foreach my $key (sort(keys %ENV)) {
	if ($key =~ /TAHOE_BUILD/ && $ENV{$key} =~ /default/) { $choice = 1; }
}
if ($choice != 1) {
	print "* default modules : @defaultmodules\n";

	# add optional modules
	print "do want to add optional modules (y/n) [n]: "; 
	$choice = <STDIN>;
	if ( $choice =~ /y/ ) {
		add_optional_modules();
	}
}
print "\n";

# write configuration file
write_config();
}

##############################################################################
sub update{

	# run all unless specified
	my @run_modules = @_;
	if (scalar(@run_modules) == 0) {
		@run_modules = @modules;
	}

	# connection type
	if ($connection =~ /cvs/) {
		update_cvs(@run_modules);
	} elsif ($connection =~ /http/) {
		update_http(@run_modules);	
	}
	else {
		print "ERROR: unrecognized connection '$connection'\n";	
		exit;
	}
}

##############################################################################
sub update_cvs {

	# run all unless specified
	my @run_modules = @_;
	if (scalar(@run_modules) == 0) {
		@run_modules = @modules;
	}

	$time = localtime();
	print "($count) updating: @modules, at $time\n";
	unlink("cvs.log");
	foreach my $dir (@run_modules) {

		next if defined($module2syslib{$dir});

		if(-d $dir) {
			print "\tupdating $dir...";
			chdir($dir);
			system("cvs update -Pd > ../cvs.log 2>&1");
			chdir("..");
		} else {
			print "\tchecking out $dir...";
			my $repo = $module2repo{$dir};
			system("cvs -d $tahoe_name\@$tahoe:$repo checkout $dir > cvs.log 2>&1");
		}
		# check for failures
		my ($errors, $patches, $updates, $merges) = (0, 0, 0, 0);
		open(IN,"cvs.log");
		while (defined(my $line = <IN>)) {
			$errors++ if ($line =~ /^C /);
			$patches++ if ($line =~ /^P /);
			$updates++ if ($line =~ /^U /);
			$merges++ if ($line =~ /^M /);
		}
		print " {U($updates), M($merges), P($patches), C($errors)}";
		if($errors > 0) {
			$script_status++;
			print " conflicts found\n";
		} else {
			print " ok\n";
		}
		
		# mark for init
		if (-d $dir && 
			$errors + $patches + $updates + $merges > 0 && 
			$module2define{$dir} !~ /NODEFINE/) {
			system("echo 'init' > $dir/.status");
		}
	}
}

##############################################################################
sub update_http {

	# run all unless specified
	my @run_modules = @_;
	if (scalar(@run_modules) == 0) {
		@run_modules = @modules;
	}

	$time = localtime();
	print "($count) updating: @modules, at $time\n";
	foreach $dir (@run_modules) {
	
		# check
		if (!defined($http_modules{$dir})) {
			print "ERROR: module $dir is not available via http\n";
			exit;
		}
	
		print "\tupdating $dir...\n";
		
		# grab new copy
		my $curl_cmd = "curl http://tahoe.ca.sandia.gov/download/nightly/$dir.tar.gz --remote-name --connect-timeout 10";
		if ($proxy !~ /NONE/) {
			$curl_cmd = $curl_cmd." --proxy $proxy";
		}
		system("$curl_cmd") == 0
			or die "ERROR: curl failed. Check connection or proxy ($proxy)";

		# move existing directory aside
		if (-d $dir) {

			# parse the date
			my ($sec, $min, $hour, $mday, $mon, $year, , , ) = localtime;
			my $the_date = sprintf("%02d%02d%04d-%02d:%02d:%02d", $mon+1, $mday, $year+1900, $hour, $min, $sec);

			# rename
			if (! -d "saved") {
				system("mkdir saved");
			}
			system("mv $dir saved/$dir.$the_date");
		} 
			
		# unpack
		system("gunzip $dir.tar.gz");
		system("tar xf $dir.tar");
		if ($module2define{$dir} !~ /NODEFINE/) {
			system("echo 'init' > $dir/.status");
		}
		
		# clean up
		system("rm $dir.tar");
		print " ok\n";
	}
}

##############################################################################
sub build {

	# run all unless specified
	my @run_modules = @_;
	if (scalar(@run_modules) == 0) {
		@run_modules = @modules;
	}

	$time = localtime();

	# confirm all modules are checked out
	foreach my $dir (@run_modules) {
		if (! -e $dir) { update($dir); }
	}

	# need to sort modules based on dependencies
	my @tmp_modules = sort by_depend @run_modules;
	print "($count) building: @tmp_modules, at $time\n";

	foreach my $dir (@tmp_modules) {

		unlink("$dir/build.log");

		# needs initialization
		if (-e "$dir/.status") { init($dir); }

		# build
		if (-e "$dir/makefile" && !defined($up_to_date_modules{$dir})) {
			print "\tmaking $dir...";
			chdir($dir);
			system("make build > build.log 2>&1");
			#system("make > build.log 2>&1");
			
			# check for errors	
			open(IN,"build.log");
			my @lines = <IN>; $file = "@lines"; close(IN); 
			my $errors = ($file =~ / error /i);
               if($errors > 0) {
               	print "ERROR\n";
               	$script_status++;
               }
			else { print " ok\n"; }
			chdir "..";
		}
	}
}

##############################################################################
sub init {

	# run all unless specified
	my @run_modules = @_;
	if (scalar(@run_modules) == 0) {
		@run_modules = @modules;
	}

	$time = localtime();

	# confirm all modules are checked out
	foreach my $dir (@run_modules) {
		if (! -e $dir) { update($dir); }
	}
	
	# need to sort modules based on dependencies
	my @tmp_modules = sort by_depend @run_modules;
	
	print "($count) initializing: @tmp_modules, at $time\n";
	foreach my $dir (@tmp_modules) {
		if (-e $dir) { 
			chdir $dir; 
			if (-e "makefile.template") {

				# generate makefile
				print "\tcreating makefile in $dir...";
				fillin_makefile();
				print " ok\n";
				
				# run "make init"
				if (!defined($up_to_date_modules{$dir})) {
					print "\tinitializing $dir...";
					system("make init > build.log 2>&1");
					print " ok\n";
				}
				
				# remove flag
				unlink(".status");
			}
		 	chdir "..";
		}
	}

}
##############################################################################
sub clean{

	# run all unless specified
	my @run_modules = @_;
	if (scalar(@run_modules) == 0) {
		@run_modules = @modules;
	}

	$time = localtime();
	print "($count) cleaning: @modules, at $time\n";
	foreach $dir (@run_modules) {
		if (-e $dir) { 
			chdir $dir; 
			if (-e "makefile") {
				print "\tcleaning $dir...";
				system("make clean >& clean.log");
				print " ok\n";
				
				# flag
				system("echo 'init' > .status");
			}
		 	chdir "..";
		}
	}

}
##############################################################################
sub test{
	$time = localtime();
	print "($count) running tests at $time\n";
 	unless(-d "benchmark_XML"){
		print "checking out benchmark\n";
		unlink("cvs.log");
		my $repo = $module2repo{"benchmark_XML"};
		system("cvs -d $tahoe_name\@$tahoe:$repo checkout benchmark_XML > cvs.log 2>&1");
 	} else {
		system("cd benchmark_XML; cvs update -Pd > cvs.log 2>&1");
	}
	chdir("benchmark_XML/comparator");
	print("\tbuilding comparator...");
	fillin_makefile(); system("make init build > build.log 2>&1");
	print(" ok\n");
	chdir("..");
	print("\trunning benchmarks");
	print("\tremoving previous results...");
	system("make clean > build.log 2>&1");
	print(" ok\n");
	print("\trunning benchmark cases...");
	system("../tahoe/tahoe -f run.batch > run.out 2>&1");
	print(" ok\n");
	print("\tcomparing benchmarks...");
	system("./comparator/compare -f run.batch > compare.out 2>&1");
	print(" ok\n");
	open(IN,"compare.summary");
	<IN>; 
	$_ = <IN>; chomp(); s/^\s+//; s/\s+$//; $pass = $_;   
	$_ = <IN>; chomp(); s/^\s+//; s/\s+$//; $fail = $_;   
	print "* $pass,  $fail, see compare.summary for more details\n";
}
##############################################################################
sub failed{
	$time = localtime();
	die "*-*-*-* process FAILED at $time *-*-*-*\n";
}

##############################################################################
sub usage {
	print "\nusage: tahoe-manager [list of keywords and options]\n";
	print "       update  : updates or checks out modules\n";
	print "       config  : change build options\n";
	print "       init    : creates makefiles and initializes modules\n";
	print "       build   : builds modules\n";
	print "       test    : runs regression tests\n";
	print "       clean   : cleans modules\n";
#	print "       all     : updates, init's and builds \n";
	print "\n";
	exit 1;
}

##############################################################################
sub a_depends_on_b {

	# needs two arguments
	if (scalar(@_) != 2) {
		print "a_depends_on_b: expecting 2 arguments\n";
	}
	my ($a, $b) = @_;

	# look for dependency in makefile
	my $source = "$a/makefile.template";
	if (-e $source) {
		open(IN, "$source");
		my @lines = <IN>; $afile = "@lines"; 
		close(IN);
		my $bdefine = $module2define{$b}; 
 		my $a_on_b = ($afile =~ /$bdefine/);
		if ($a_on_b > 0) { return 1; }
	}
	return 0;
}

##############################################################################
sub by_depend {

	my $filename = "$a/makefile.template";
	my $a_on_b = -1;
	if (-e $filename) {
		open(IN,"$filename");
		my @lines = <IN>; $afile = "@lines"; 
		close(IN);
		my $bdefine = $module2define{$b}; 
 		$a_on_b = ($afile =~ /$bdefine/);
		unless($a_on_b > 0) {$a_on_b = 0;}
	}

	$filename = "$b/makefile.template";
	my $b_on_a = -1;
	if (-e $filename) {
		open(IN,"$filename");
		my @lines = <IN>; $bfile = "@lines"; 
		close(IN);
		my $adefine = $module2define{$a};
		$b_on_a = ($bfile =~ /$adefine/);
		unless($b_on_a > 0) {$b_on_a = 0;}
	}

	# bi-directional dependency with tahoe => tahoe goes last
	if ($a_on_b == $b_on_a && ($a =~ /^tahoe$/ || $b =~ /^tahoe$/) ) {
		if ($a =~ /^tahoe$/) {
			$a_on_b = $b_on_a + 1;
		} else {
			$b_on_a = $a_on_b + 1;
		}
	}

	#print " $a $a_on_b $b $b_on_a \n";

	($a_on_b <=> $b_on_a);
}

##############################################################################
sub fillin_makefile{

	# if makefile exists, preserve MOD_ macros in makefile
	my %mod_macros = qw(
		MOD_CFLAGS_C 0
		MOD_CFLAGS_CC 0
		MOD_CFLAGS_F 0
		MOD_LFLAGS 0
	);
	my @mod_macros_keys = ();
	if (-e "makefile") {
		open(IN, "makefile");
		@mod_macros_keys = keys(%mod_macros);
		while (defined($line = <IN>)) {
			foreach my $key (@mod_macros_keys) {
				if ($line =~ /$key\s*=/) {
					$mod_macros{$key} = $line;
				}
			}
		}
		close (IN);
	}

	unlink("makefile");
	my $path = cwd();
	open(IN,"makefile.template");
	open(OUT,">makefile");
	print OUT "################################################################################\n";
	print OUT "#### NOTE: This makefile is automatically generated from makefile.template. ####\n";
	print OUT "####       Changes to the MOD_ macros are preserved. All other changes will ####\n";
	print OUT "####       be lost.                                                         ####\n";
	print OUT "################################################################################\n\n";
	while (defined(my $line = <IN>)){
	
		# configuration
		$line =~ s/HOME_DIR =/HOME_DIR = $path/;
		$line =~ s/ARCH =/ARCH = $arch/;
		
		# restore MOD_ macros
		foreach my $key (@mod_macros_keys) {
			if ($line =~ /$key\s*=/) {
				$line = $mod_macros{$key};
			}
		}
		
		# optional modules
		foreach my $module (@modules) {
			my $define = $module2define{$module};
			$line =~ s/\#$define/$define/;
		}
		foreach my $syslib (@syslibs) {
			my $define = $module2define{$syslib2module{$syslib}};
			$line =~ s/\#$define/$define/;
		}
		
		# UP_TO_DATE modules - tahoe module only
		if ($path =~ /tahoe-install\/tahoe/ && $line =~ /UP_TO_DATE\ =\ NONE/) {
			$up_to_date = "";
			foreach $module (@modules) {
				if (defined($up_to_date_modules{$module})) {
					$up_to_date = $up_to_date." \$(".$module2define{$module}."DIR)";
				}
			}
			if (length($up_to_date) > 0) {
				$line =~ s/=\ NONE/=$up_to_date/;
			}
		}
		
		print OUT "$line";
 	}
	close(IN);
	close(OUT);
}

##############################################################################
sub my_which{
	my $cmd = shift(@_); 
        my $location = "";
        my @paths= split(":",$ENV{"PATH"});
        foreach my $path (@paths) {
                if (-x "$path/$cmd") { $location = $path; last;}
        }
        return $location;
}

##############################################################################
sub write_config {
	open(CONFIG,">$config_file") || die "cannot open file $config_file for writing : $!";
	print CONFIG  "# TAHOE_LOGIN\n$tahoe_name\n\n";
	print CONFIG  "# CONNECTION\n$connection\n\n";
	print CONFIG  "# PROXY\n$proxy\n\n";
	print CONFIG  "# ARCHITECTURE\n$arch\n\n";
	print CONFIG  "# MODULES\n@modules\n\n";
	print CONFIG  "# EOF";
	close(CONFIG);
}

##############################################################################
sub add_optional_modules {

	# collect optional modules not currently included
	my @newoptionalmodules = ();
	foreach my $opt_module (@optionalmodules) {
		my $found = 0;
		foreach my $module (@modules) {
			if ($module =~ /$opt_module/) {
				$found = 1;
			}
		}
		if ($found == 0) {
			push(@newoptionalmodules, $opt_module);
		}
	}

	# select modules to add
	print "\noptional modules:\n";
	my $i=0;
	foreach my $choice (@newoptionalmodules) { 
		print "$i $choice\n"; 
		$i++;
	}
	print "\nmodule numbers to add: "; 
	$choice = <STDIN>; 
	chomp($choice);
	my @choices = split(/ +|,/,$choice);

	# flag modules that need to be re-initialized
	foreach my $module (@modules) {
		if (a_depends_on_b($module, $newoptionalmodules[$choice]) == 1) {
			system("echo 'init' > $module/.status");
		}
	}

	# rebuild module list
	foreach $choice (@choices) { 
		push (@modules, $newoptionalmodules[$choice]);
	}
	print "* modules : @modules \n";
}

##############################################################################
sub remove_optional_modules {

	# collect optional modules currently included
	my @curr_optionalmodules = ();
	foreach my $opt_module (@optionalmodules) {
		my $found = 0;
		foreach $module (@modules) {
			if ($module =~ /$opt_module/) {
				$found = 1;
			}
		}
		if ($found == 1) {
			push(@curr_optionalmodules, $opt_module);
		}
	}
	
	# select modules to remove
	print "\noptional modules:\n";
	my $i=0;
	foreach my $choice (@curr_optionalmodules) { 
		print "$i $choice\n"; 
		$i++;
	}
	print "\nmodule numbers to remove: "; 
	my $choice = <STDIN>; 
	chomp($choice);
	my @choices = split(/ +|,/,$choice);

	# flag modules that need to be re-initialized
	foreach my $module (@modules) {
		if (a_depends_on_b($module, $curr_optionalmodules[$choice]) == 1) {
			system("echo 'init' > $module/.status");
		}
	}

	# rebuild modules list
	foreach $choice (@choices) {
		my @modules_tmp = @modules;
		@modules = ();
		foreach my $module (@modules_tmp) {
			if ($module !~ /$curr_optionalmodules[$choice]/) {
				push(@modules, $module);
			}
		}
	}
	print "* modules : @modules \n";
}

##############################################################################
sub module_config {

	# collect list of configurable modules
	my @config_modules = ();
	foreach my $module (@modules) {
		if (-d "$module/config") {
			open(CHECK, "ls -1 $module/config | grep -c \.conf |");
			my $count = <CHECK>;
			chomp($count);
			close(CHECK);
			if ($count > 0) {
				push(@config_modules, $module);
			}
		}
	}
	
	if (scalar(@config_modules) == 0) {
		print "\nThere are no modules with configurable options\n";
	}
	else {
		print "\nconfigurable modules:\n";
		my $i=0;
		foreach my $choice (@config_modules) { 
			print "$i $choice\n"; 
			$i++;
		}
		print "\nmodules to configure: ";
		my $choice = <STDIN>; 
		chomp($choice);				
		my @choices = split(/ +|,/,$choice);
		foreach $choice (@choices) {	
			configure_module($config_modules[$choice]);
		}
	}
}

##############################################################################
sub configure_module {
	my $module = shift(@_);
	
	# regenerate the configuration headers
	chdir $module;
	fillin_makefile();
	system("make update_config > build.log 2>&1");
	
	# find configuration headers
	@config_headers = ();
	open(LS, "ls -1 src-mirror/config |");
	while (defined($file = <LS>)) {
		chomp($file);
		if ($file =~ /\.h$/) {
			push(@config_headers, $file);
		}
	}

	if (scalar(@config_headers) == 0) {
		print "\nThere are no headers with configurable options\n";	
	} else {
		print "\nconfigurable headers in module $module:\n";
		$i=0;
		foreach my $choice (@config_headers) { 
			print "$i $choice\n"; 
			$i++;
		}	print "\nheaders to configure: ";
		my $choice = <STDIN>; 
		chomp($choice);
		my @choices = split(/ +|,/,$choice);
		foreach $choice (@choices) {	
			if (configure_header($config_headers[$choice]) != 0) {
				system("echo 'init' > .status");
			}
		}
	}

	# up
	chdir "..";
}

##############################################################################
sub configure_header {
	my $header = shift(@_);
	print "configuring header $header\n";
	return 0;
}

##############################################################################
sub print_in_columns {
	my $cols = shift(@_);
	my @choices = @_;
	
	# find longest name
	my $max_len = 0;
	my $choice;
	foreach $choice (@choices) {
		if (length($choice) > $max_len) { $max_len = length($choice); }
	}
	my $col_width = $max_len + 3 + 10; # 3 for item number and gap
	my $num_values = scalar(@choices);
	my $jump = int($num_values/($cols))+1;
	my $i = 0;
	while ($i < $jump) {
		my $line = "";
		my $col = 0;
		my $ii = $i;
		while ($col < $cols) {
			my $col_i = "";
			if ($ii < 10) { $col_i = $col_i." "; }
			if ($ii < $num_values) { $col_i = $col_i.$ii." $choices[$ii]"; }
			while ($col != $cols-1 && length($col_i) < $col_width) { $col_i = $col_i." "; }
			$col++;
			$ii += $jump;
			$line = $line.$col_i;
		}
		print "$line\n";
		$i++;
	}
}
