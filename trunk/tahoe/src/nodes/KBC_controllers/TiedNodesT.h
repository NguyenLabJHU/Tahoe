/* $Id: TiedNodesT.h,v 1.1 2002-04-10 16:48:24 paklein Exp $ */

#ifndef _TIED_NODES_T_H_
#define _TIED_NODES_T_H_

/* base class */
#include "KBC_ControllerT.h"

/* direct members */
#include "iArray2DT.h"
#include "iArrayT.h"
#include "LoadTime.h"
#include "AutoArrayT.h"

/* forward declarations */
class dArray2DT;

/** class to tie nodes together and release them under specified conditions.
 * The class accomplishes this in the following way:
 * <ul> 
 * <li> paired nodes are returned as connectivities in TiedNodesT::Connects
 *      so that the graph for the mesh reflects the tied condition.
 * <li> KBC_CardT's are generated during the call to TiedNodesT::InitStep for each 
 *      degree of freedom of the \e follower nodes to reflect that these degrees 
 *      of freedom are not active.
 * <li> The degrees of freedom from the \e leader nodes are copied into the
 *      degrees of freedom of the \e follower nodes in calls to TiedNodesT::InitStep
 *      and TiedNodesT::Update so that the \e followers follow. Additionally, the
 *      equation numbers from the \e leader nodes are copied into the equations of
 *      the follower node during the call to TiedNodesT::InitStep, so the global
 *      equation system reflects the tied conditions.
 * <li> The tied constraints can be tested and released during the call to
 *      TiedNodesT::RelaxSystem.
 * </ul> */
class TiedNodesT: public KBC_ControllerT
{
public:	

	/** constructor */
	TiedNodesT(NodeManagerT& node_manager);

	/** initialize data. Must be called immediately after construction */
	virtual void Initialize(ifstreamT& in);
	virtual void WriteParameters(ostream& out) const;

	/** set to initial conditions. Reset all conditions to tied. */
	virtual void InitialCondition(void);

	/** \name restart functions */
	/*@{*/
	virtual void ReadRestart(istream& in);
	virtual void WriteRestart(ostream& out) const;
	/*@}*/

	/** \name solution steps
	 * Methods signaling different stages of the solution process for
	 * a single time step. */
	/*@{*/
	/** initialize the current step */
	virtual void InitStep(void);

	/** computing residual force */
	virtual void FormRHS(void);

	/** signal that the solution has been found */
	virtual void CloseStep(void);

	/** solution for the current step failed. Restore system to its
	 * state at the beginning of the current time step. */
	virtual void Reset(void);
	/*@}*/

	/** see if pair status has changed */
	virtual GlobalT::RelaxCodeT RelaxSystem(void);

	/** append connectivities generated by the controller. By default, 
	 * does not append any connectivities to the list */
	virtual void Connects(AutoArrayT<const iArray2DT*>& connects) const;

	/** \name TiedNodesT extras
	 * extra information needed by this class */
	/*@{*/	 
	void SetEquations(iArray2DT& eqnos) { fEqnos = &eqnos; };
	void AddKinematics(dArray2DT& u);
	/*@}*/	 

protected:

	/** pair status */
	enum StatusT {
		kTied = 1, /**< nodes move together */
		kFree = 0  /**< nodes are independent */};

protected:

	/** the tied node pairs */
	/*@{*/
	/** id list for the \e leader node sets */
	ArrayT<StringT> fLeaderIds;

	/** id list for the \e leader node sets */
	ArrayT<StringT> fFollowerIds;
	
	/** first node is \e follower second node is \e leader or -1 if no
	 * leader is found. */
	iArray2DT fNodePairs;	

	/** status of the pair in terms of TiedNodesT::StatusT */
	iArrayT fPairStatus;

	/** status history */
	iArrayT fPairStatus_last;
	/*@}*/
	
	/** equations numbers of the global system */
	iArray2DT* fEqnos;

	/** list of kinematics for the nodes */
	AutoArrayT<dArray2DT*> fKinematics;
	
	/** needed to generate KBC_ControllerT::fKBC_Cards */
	LoadTime fDummySchedule;	
};

#endif /* _TIED_NODES_T_H_ */
