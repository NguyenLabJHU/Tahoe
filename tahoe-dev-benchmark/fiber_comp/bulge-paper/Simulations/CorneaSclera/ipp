#!/usr/bin/perl
# to do :
# priority (overide file defaults e.g. a=1 pfile a=2 -> a=2)

# Read command line arguments 
for ($i = 0; $i < scalar(@ARGV); $i++) {
  $arg = $ARGV[$i];
  if    ($arg =~ /-p/) { $params_file = $ARGV[++$i]; 
    # Open parameters file for input.
    open (PARAMS, "<$params_file") || 
    die "Can't open parameter file: $params_file: $!";
    while (<PARAMS>) { 
      ($tag, $value) = m/\{\s*(\w+)\s*=\s*(\d+|-?\d\.\d+e(?:\+|-)\d+)\s*\}/o;
      $values_p1{$tag} = $value; # store in hash
    }
    close (PARAMS);
  }
  elsif ($arg =~ /-o/) { $new_file = $ARGV[++$i]; }
  elsif ($arg =~ /=/)  { ($tag,$value) = split(/=/,$arg);
    #($tag, $value) = m/\{\s*(\w+)\s*=\s*(\d+|-?\d\.\d+e(?:\+|-)\d+)\s*\}/o;
    $values_p1{$tag}  = $value;
  } 
  else                 { $template_file = $ARGV[$i]; }
}

# Check for correct command line arguments 
if( ! defined($template_file) ) {
  print STDERR "Usage: ipp <-p parameters_file> <name=value> template_file <-o new_file>\n";
  exit(-1);
}

# debug : print key--> value
#foreach $key (keys %values_p1) { 
#  print $key, "---> ",$values_p1{$key},"\n";
#}

# Open the template file for input.
open (TEMPLATE_FILE, "<$template_file") ||
  die "Can't open template file: $template_file: $!";
# Open the new file for output.
if (defined($new_file)) {
  open (NEW_FILE, ">$new_file") || die "Can't create new file: $new_file: $!";
}

$print = 1; # print line flag
while (<TEMPLATE_FILE>) {

  # Extract each {} match from this line
  foreach $field (m/\{\s*(.+?)\s*\}/go) { # ".+?" provides a minimal match

    # Case 1: test for simple tag match "{tag}"
    if ($field =~ m/^\w+$/o) {
      if ( defined ( $value = $values_p1{$field} ) ||
           defined ( $value = $values_p2{$field} ) ) { # or exists $values{$tag}
        s/\{\s*$field\s*\}/$value/;
      }
    }

    # Case 2: test for assignment "{tag = field}"
    elsif ( ($tag, $assign) = ($field =~ m/^(\w+)\s*=\s*(.+?)$/o) ) {

      # Case 2a: assignment of numerical value (integral, floating point, or
      # scientific notation)
      if ($assign =~ m/^(-?\d+\.?\d*|-?\.\d+|-?\d\.\d+[eEdD][+-]\d+)$/o) {
        $assign =~ s/[dD]/e/o;               # convert F77 dbl prec exponents
        $values_p2{$tag} = $assign;          # store in priority 2 hash
        s/\{\s*$tag\s*=\s*.+?\s*\}/$assign/; # replace assignment with value
      }

      # Case 2b: assignment of expression.  Evaluate $assign by replacing any
      # known tags with their values and then eval the remaining expression.
      else {
        foreach $exptag ($assign =~ m/\b(\w*[a-zA-Z_]+\w*)\b/go) {
          if ( defined ( $value = $values_p1{$exptag} ) ||
               defined ( $value = $values_p2{$exptag} ) ) {
            $assign =~ s/$exptag/$value/;
          }
        }
        $value = eval $assign;
        if ($@) { die "Eval error: $@"; }
        $values_p2{$tag} = $value;          # store in priority 2 hash
        s/\{\s*$tag\s*=\s*.+?\s*\}/$value/; # replace assignment with value
      }
    }

    # Case 3: assume general expression in all remaining $field matches.
    # Evaluate $field by replacing any known tags with their values and
    # then eval the remaining expression.
    else {
      foreach $tag ($field =~ m/\b(\w*[a-zA-Z_]+\w*)\b/go) {
        if ( defined ( $value = $values_p1{$tag} ) ||
             defined ( $value = $values_p2{$tag} ) ) {
          $field =~ s/$tag/$value/;
        }
      }
      s/\{\s*.+?\s*\}/eval $field/e;
      if ($@) { die "Eval error: $@"; }
    }
  }

  # if/else blocks
  $skip_line = 1;
  if ($_ =~ /#if/) {
		$line = $_; chomp($line); $line =~ s/^\s+//; $line =~ s/\s+$//;
    @items = split(/\s+/,$line);
    if (eval($items[1])) { 
      if ( ($items[1] =~ /false/) || ($items[1] =~ /F/) ) { $print = 0;}
    }
    else { $print = 0;}
	} 
  elsif ($_ =~ /#else/) {
		if ($print) {$print = 0;} else {$print = 1;}
	} 
  elsif ($_ =~ /#endif/) {
		$print = 1;
	} 
  else { $skip_line = 0; }
   

  # output the processed line to the new simulation file
  if ($print && ! ($skip_line) ) {
    if (defined($new_file)) { print NEW_FILE $_;}
    else                    { print          $_;}
  }
}
close (TEMPLATE_FILE);
if (defined($new_file)) { close (NEW_FILE); }

# Print %values for debugging purposes.
#foreach $tag (sort keys %values) {
#  print $tag, " ", $values{$tag}, "\n";
#}

##########################################
# End script, begin subroutine definitions
##########################################

# Intrinsic numeric operators include +,-,*,/,**,%,<<,>>,sqrt(),abs(),
# sin(),cos(),atan2(),exp(),log(),int(),hex(),oct(),rand(),srand().

# Augment these with others (adapted/extended from bprepro by Bob Walton).
# NOTE: convert from degs to rads by pi/180 = (pi/4)/45 = atan2(1,1)/45
#       convert from rads to degs by 180/pi = 45/atan2(1,1)

# additional logarithmic functions

sub log10 { log($_[0])/log(10) }

# additional trigonometric functions with radian input

sub tan { sin($_[0])/cos($_[0]) }

sub cot { cos($_[0])/sin($_[0]) }

sub csc { 1/sin($_[0]) }

sub sec { 1/cos($_[0]) }

# trigonometric functions with degree input

sub sind { sin($_[0]*atan2(1,1)/45) }

sub cosd { cos($_[0]*atan2(1,1)/45) }

sub tand { tan($_[0]*atan2(1,1)/45) }

sub cotd { cot($_[0]*atan2(1,1)/45) }

sub cscd { 1/sin($_[0]*atan2(1,1)/45) }

sub secd { 1/cos($_[0]*atan2(1,1)/45) }

# inverse trigonometric functions returning radians

sub asin {
  if (abs($_[0]) > 1) { die "input out of range in asin()\n"; }
  atan2($_[0],sqrt(1-$_[0]**2));
}

sub acos {
  if (abs($_[0]) > 1) { die "input out of range in acos()\n"; }
  atan2(sqrt(1-$_[0]**2),$_[0]);
}

sub atan { atan2($_[0],1) }

# inverse trigonometric functions returning degrees

sub asind { asin($_[0])*45/atan2(1,1) }

sub acosd { acos($_[0])*45/atan2(1,1) }

sub atand { atan2($_[0],1)*45/atan2(1,1) }

sub atan2d { atan2($_[0],$_[1])*45/atan2(1,1) }

# hyperbolic functions

sub sinh { (exp($_[0]) - exp(-$_[0]))/2 }

sub cosh { (exp($_[0]) + exp(-$_[0]))/2 }

sub tanh { sinh($_[0])/cosh($_[0]) }

sub coth {
  if ($_[0] == 0) { die "input out of range in coth()\n"; }
  cosh($_[0])/sinh($_[0]);
}

sub csch {
  if ($_[0] == 0) { die "input out of range in csch()\n"; }
  1/sinh($_[0]);
}

sub sech { 1/cosh($_[0]) }

# inverse hyperbolic functions

sub asinh { log($_[0] + sqrt($_[0]**2 + 1)) }

sub acosh {
  if ($_[0] < 1) { die "input out of range in acosh()\n"; }
  log($_[0] + sqrt($_[0]**2 - 1));
}

sub atanh {
  if (abs($_[0]) >= 1) { die "input out of range in atanh()\n"; }
  log((1+$_[0])/(1-$_[0]))/2;
}
