(************** Content-type: application/mathematica **************
                     CreatedBy='Mathematica 5.0'

                    Mathematica-Compatible Notebook

This notebook can be used with any Mathematica-compatible
application, such as Mathematica, MathReader or Publicon. The data
for the notebook starts with the line containing stars above.

To get the notebook into a Mathematica-compatible application, do
one of the following:

* Save the data starting with the line of stars above into a file
  with a name ending in .nb, then open the file inside the
  application;

* Copy the data starting with the line of stars above to the
  clipboard, then use the Paste menu command inside the application.

Data for notebooks contains only printable 7-bit ASCII and can be
sent directly in email or through ftp in text mode.  Newlines can be
CR, LF or CRLF (Unix, Macintosh or MS-DOS style).

NOTE: If you modify the data for this notebook not in a Mathematica-
compatible application, you must delete the line below containing
the word CacheID, otherwise Mathematica-compatible applications may
try to use invalid cache data.

For more information on notebooks and Mathematica-compatible 
applications, contact Wolfram Research:
  web: http://www.wolfram.com
  email: info@wolfram.com
  phone: +1-217-398-0700 (U.S.)

Notebook reader applications are available free of charge from 
Wolfram Research.
*******************************************************************)

(*CacheID: 232*)


(*NotebookFileLineBreakTest
NotebookFileLineBreakTest*)
(*NotebookOptionsPosition[     19854,        371]*)
(*NotebookOutlinePosition[     20820,        401]*)
(*  CellTagsIndexPosition[     20776,        397]*)
(*WindowFrame->Normal*)



Notebook[{
Cell[BoxData[
    \(\(\( (*\ export\ this\ a\ mathematic\ v2, \ 
      and\ edit\ the\ text\ file\ for\ "\<font\>"\ and\ enclosing\ comments\ \
*) \)\(\[IndentingNewLine]\)\(Off[General::spell1]; 
    Off[General::spell];\[IndentingNewLine]\[IndentingNewLine]
    \(errchk\  = True;\)\[IndentingNewLine]\[IndentingNewLine]
    \(compare[alpha_, beta_\ , mu_, taulo_, taudif_, c_] := 
        Module[{}, \[IndentingNewLine]TimeConstrained[\[IndentingNewLine]If[
              errchk, Export["\<parameters.dat\>", \ 
                parameters]]; \
\[IndentingNewLine]\[IndentingNewLine]StressScale = 6.8947; \  (*\ 
              psi\  \[Rule] \ 
                kPa\ *) \[IndentingNewLine]\[IndentingNewLine] (*\ 
              assumed\ parameters\ *) \[IndentingNewLine]nu\  = \ 
              0.49; \[IndentingNewLine]gamma = nu/\((1 - 2\ nu)\); \  (*\ 
              nearly\ incompressible\ *) \[IndentingNewLine]\
\[IndentingNewLine]\[IndentingNewLine] (*\ 
              relaxation\ kernel\ constants\ FUNG*) \[IndentingNewLine]tau1 = \
\ 10^taulo; \[IndentingNewLine]tau2\  = 
              10^\((taulo + taudif)\); \[IndentingNewLine]Goo\  = \ 
              1/\((1 + \ 
                    c\ Log[tau2/
                          tau1])\); \[IndentingNewLine]\[IndentingNewLine] \
(*\ fiber\ *) \  (*\ 
              compressive\ behavior\ ?? \ *) \[IndentingNewLine]Wf[l_]\  = \ 
              alpha \((\ 
                  Exp[beta \((l - 1)\)] - beta\ l)\); \[IndentingNewLine]Wfp[
                l_]\  = \ D[Wf[l], l]; \[IndentingNewLine]Wfpp[l_]\  = \ 
              D[Wfp[l], l]; \[IndentingNewLine]\[IndentingNewLine] (*\ 
              orientation\ *) \[IndentingNewLine]Theta\  = {Cos[t], \ 
                Sin[t]}; \[IndentingNewLine]MatrixForm[
              M\  = \ Outer[Times, Theta, \ 
                  Theta]]; \[IndentingNewLine]I4\  = \ \ l1^2\ Cos[t]^2 + 
                l2^2\ Sin[t]^2; \[IndentingNewLine]\[IndentingNewLine] (*\ 
              fiber\ traction\ along\ principal\ directions\ \
*) \[IndentingNewLine]sf1[l1_, l2_, l3_]\ \  = \ 
              2\ Wfp[I4]\ \ M[\([1, 1]\)]\ ; \[IndentingNewLine]sf2[l1_, l2_, 
                l3_]\ \  = \ 
              2\ Wfp[I4]\ \ M[\([2, 
                    2]\)]; \ \[IndentingNewLine]\[IndentingNewLine] (*\ 
              elasticity\ \(tensor\  : \ 
                  2\ dW/dI\ dI/dC\)\ *) \[IndentingNewLine]kf11[l1_, l2_, 
                l3_]\  = \ 
              4\ Wfpp[I4]\ M[\([1, 1]\)]\ M[\([1, 
                    1]\)]\ ; \[IndentingNewLine]kf12[l1_, l2_, l3_]\  = \ 
              4\ Wfpp[I4]\ M[\([1, 1]\)]\ M[\([2, 
                    2]\)]\ ; \[IndentingNewLine]kf22[l1_, l2_, l3_]\  = \ 
              4\ Wfpp[I4]\ M[\([2, 2]\)]\ M[\([2, 
                    2]\)]\ ; \[IndentingNewLine]\[IndentingNewLine] (*\ 
              homogenization\ integral, \ 
              isotropic\ \ has\ analytic\ forms\ *) \[IndentingNewLine]H\  = 
              1.0/\((2.0\ Pi)\)\ NIntegrate[#1\ , {t, \(-Pi\), Pi}, 
                    AccuracyGoal \[Rule] 
                      10]\  &; \[IndentingNewLine] (*\ \(! \(! \(! \ 
                    num\ \(\(here\)\(\ \)\(?\)\)\)\)\)\ \
*) \[IndentingNewLine] (*\ 
              matrix, \ \(\(neohookean\)\(?\)\)\ *) \[IndentingNewLine]J = 
              l1\ l2\ l3; \[IndentingNewLine]Um[l1_, l2_, l3_]\  = \ 
              mu/2 \((l1^2 + l2^2 + l3^2 - 3)\)\  + \ 
                mu/\((2\ gamma)\)\ \((J^\((\(-2\) gamma)\)\  - 
                      1)\); \[IndentingNewLine]\[IndentingNewLine] (*\ 
              2  PK\ principal\ \(stress\  : \ 
                  2  dU/dl\ dl/dC\)\ *) \[IndentingNewLine]sm1[l1_, l2_, 
                l3_]\  = \ 
              D[Um[l1, l2, l3], l1]/l1; \[IndentingNewLine]sm2[l1_, l2_, 
                l3_]\  = \ 
              D[Um[l1, l2, l3], l2]/l2; \[IndentingNewLine]sm3[l1_, l2_, 
                l3_]\  = \ 
              D[Um[l1, l2, l3], l3]/
                l3; \[IndentingNewLine]\[IndentingNewLine] (*\ 
              elasticity\ tensor\ 2  dS/dC\  = \ 
                2\ dS/dl\ dl/dC*) \[IndentingNewLine]Cm11[l1_, l2_, 
                l3_]\  = \ 
              D[sm1[l1, l2, l3], l1]/l1; \[IndentingNewLine]Cm12[l1_, l2_, 
                l3_]\  = \ 
              D[sm1[l1, l2, l3], l2]/l2; \[IndentingNewLine]Cm13[l1_, l2_, 
                l3_]\  = \ 
              D[sm1[l1, l2, l3], l3]/l3; \[IndentingNewLine]Cm22[l1_, l2_, 
                l3_]\  = \ 
              D[sm2[l1, l2, l3], l2]/l2; \[IndentingNewLine]Cm23[l1_, l2_, 
                l3_]\  = \ 
              D[sm2[l1, l2, l3], l3]/l3; \[IndentingNewLine]Cm33[l1_, l2_, 
                l3_]\  = \ 
              D[sm3[l1, l2, l3], l3]/
                l3; \[IndentingNewLine]\[IndentingNewLine] (*\ \(total\ 2  
                    PK\ stress\  &\)\ elasticity\ tensor\ \
*) \[IndentingNewLine]stress[l1m_, l2m_, 
                l3m_]\  := \ \[IndentingNewLine]\ {H[sf1[l1m, l2m, l3m]], \ 
                  H[sf2[l1m, l2m, l3m]], \ 0}\  + \n{\ sm1[l1m, l2m, l3m], \ 
                  sm2[l1m, l2m, l3m], \ 
                  sm3[l1m, l2m, 
                    l3m]}; \n\[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]stiffness[l1m_, l2m_, l3m_]\  := \ 
              Module[{CF11, \ CF12, \ CF22, CM11, CM12, CM13, CM22, CM23, 
                  CM33, C}, \[IndentingNewLine]CF11 = \ 
                  H[kf11[l1m, l2m, l3m]]; \[IndentingNewLine]CF12 = \ 
                  H[kf12[l1m, l2m, l3m]]; \[IndentingNewLine]CF22 = \ 
                  H[kf22[l1m, l2m, l3m]]; \[IndentingNewLine]CM11 = 
                  Cm11[l1m, l2m, l3m]; \[IndentingNewLine]CM12 = 
                  Cm12[l1m, l2m, l3m]; \[IndentingNewLine]CM13 = 
                  Cm13[l1m, l2m, l3m]\ ; \[IndentingNewLine]CM22 = 
                  Cm22[l1m, l2m, l3m]\ ; \[IndentingNewLine]CM23 = 
                  Cm23[l1m, l2m, l3m]\ ; \[IndentingNewLine]CM33 = 
                  Cm33[l1m, l2m, 
                    l3m]\ ; \[IndentingNewLine]C = {{CF11 + CM11, 
                      CF12 + CM12, CM13}, \[IndentingNewLine]{CF12 + CM12, 
                      CF22 + CM22, CM23}, \[IndentingNewLine]{CM13, CM23, 
                      CM33}}; \[IndentingNewLine]C\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]\[IndentingNewLine] (*\ 
              Fung' s\ relaxation\ function\ *) \[IndentingNewLine]E1[
                x_]\  = \ 
              ExpIntegralE[1, x]; \[IndentingNewLine]G[
                t_]\  = \ \ Goo \((1\  + \ 
                    c\ \((\ E1[t/tau2] - 
                          E1[t/tau1])\))\); \[IndentingNewLine]G0\  = \ 
              Goo \((1\  + \ 
                    c\ \((Limit[\ E1[t/tau2] - E1[t/tau1], 
                          t \[Rule] 0])\))\); \[IndentingNewLine]Goo = 
              Limit[G[t], t \[Rule] Infinity]; \[IndentingNewLine]dG[t_]\  = 
              D[G[t], t]; \[IndentingNewLine]dG0 = 
              Limit[dG[t], 
                t \[Rule] 
                  0]; \[IndentingNewLine]\[IndentingNewLine]tolG\  = \ 
              10^\((\(-8\))\); \[IndentingNewLine]tmax = 
              t /. FindRoot[
                  dG[t] \[Equal] \(-tolG\), {t, 
                    2}]; \[IndentingNewLine]\[IndentingNewLine]\n
            strainHistory[dt_, \ sh_] := \ 
              Module[{maxClockTime\  = \ 60*5, ntsteps = 0, ts = {}, 
                  tolR\  = \ 10^\((\(-8\))\), sigma, sigma0, sigint, errorR, 
                  Gscale, Gs = {}, dGs = {}, l1m = 1, l2m = 1, l3m = 1, 
                  outInt = 
                    100}, \[IndentingNewLine]\[IndentingNewLine] (*allot\ \
space\ *) \[IndentingNewLine]ntsteps\  = \ 
                  First[Dimensions[sh]]; \[IndentingNewLine]ts = 
                  Range[0, dt*\((ntsteps - 1)\), 
                    dt]; \[IndentingNewLine]sigint = \ 
                  Table[{0, 0, 0}, {k, 
                      ntsteps}]; \ \[IndentingNewLine]stretches\  = \ 
                  sigint; \[IndentingNewLine]\[IndentingNewLine] (*\ 
                  compute\ dG\ on\ uniform\ time\ grid, \ 
                  and\ truncate\ if\ long\ time\ history\ \
*) \[IndentingNewLine]If[Last[ts] > \ tmax, \ 
                  If[errchk, 
                    Print["\<can truncate dG\>"]]]; \[IndentingNewLine]dGs\  \
= Map[dG, Drop[ts, 1]]; \[IndentingNewLine]Gs\  = 
                  Map[G, Drop[ts, 1]]; \[IndentingNewLine]Gscale\  = \ 
                  G0 + dt*dG0; \[IndentingNewLine]\[IndentingNewLine]For[
                  m\  = \ 1, \ 
                  m \[LessEqual] 
                    ntsteps, \ \(m++\), \[IndentingNewLine]time0 = 
                    TimeUsed[]; \[IndentingNewLine]\[IndentingNewLine] (*\ 
                    trial\ 2  
                      PK\ principal\ stress\ *) \[IndentingNewLine]sigma\  = 
                    stress[l1m, l2m, 
                      l3m]; \[IndentingNewLine]\[IndentingNewLine] (*\ 
                    convolution : \ 
                      G0\ T\  + \ 
                        int^t_  
                          0\ dG \((t)\)\ T \((s - 
                              t)\)\ ds\ *) \[IndentingNewLine]sigma0 = 
                    dt*Take[dGs, m - 1] . 
                        Reverse[Take[sigint, m - 1]]; \  (*\ 
                    fixed\ part\ of\ the\ stress\ *) \[IndentingNewLine]sigma\
\  = Gscale*sigma + sigma0; \[IndentingNewLine]\[IndentingNewLine] (*\ 
                    force\ balance\ *) \[IndentingNewLine]Rext\  = 
                    sh[\([m]\)]/\ {l1m, l2m, \ 
                        l3m}; \[IndentingNewLine]Res0\  = 
                    Rext - sigma; \[IndentingNewLine]errorR\  = \ 
                    Sqrt[Res0 . 
                        Res0]; \ \[IndentingNewLine]\[IndentingNewLine]errors\
\  = \ {}; \[IndentingNewLine]While[\((\ 
                      errorR\  > \ tolR)\), \[IndentingNewLine] (*\ 
                      stiffness\ *) \[IndentingNewLine]K = \ 
                      stiffness[l1m, l2m, l3m] . 
                        DiagonalMatrix[{l1m, l2m, 
                            l3m}]; \[IndentingNewLine]\[IndentingNewLine] (*\ 
                      derivative\ of\ convolution\ *) \ \[IndentingNewLine]K\ \
 *= Gscale; \[IndentingNewLine]K -= 
                      DiagonalMatrix[\(-sh[\([m]\)]\)/{l1m*l1m, \ l2m*l2m, 
                            l3m*l3m}]; \
\[IndentingNewLine]\[IndentingNewLine]{l1m, \ l2m, l3m}\  += \ 
                      Inverse[K] . Res0; \[IndentingNewLine]If[
                      l1m \[LessEqual] 0 || l2m \[LessEqual] 0 || 
                        l3m \[LessEqual] 0, 
                      If[errchk, 
                        Print["\<negative stretch : \>", {l1m, \ l2m, l3m}]]; 
                      Abort[]\ ]; \[IndentingNewLine]\[IndentingNewLine] (*\ 
                      new\ elastic\ stress\ *) \[IndentingNewLine]sigma\  = \ \
\(sigint[\([m]\)] = stress[l1m, l2m, 
                          l3m]\); \[IndentingNewLine]\[IndentingNewLine] (*\ 
                      convolution\ *) \[IndentingNewLine]sigma\  = 
                      Gscale*sigma + 
                        sigma0; \[IndentingNewLine]\[IndentingNewLine] (*\ 
                      force\ balance\ *) \[IndentingNewLine]Rext\  = 
                      sh[\([m]\)]/\ {l1m, l2m, \ 
                          l3m}; \[IndentingNewLine]Res0\  = 
                      Rext - sigma; \[IndentingNewLine]errorR\  = \ 
                      Sqrt[Res0 . Res0]; \[IndentingNewLine]AppendTo[errors, 
                      errorR];\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]If[
                    errchk && 
                      Mod[m, outInt] \[Equal] 0, \(Print[m, "\< / \>", \ 
                        ntsteps];\)]; \
\[IndentingNewLine]\[IndentingNewLine]sigint[\([m]\)] = 
                    sigma; \[IndentingNewLine]stretches\ [\([m]\)]\  = \ \
{l1m, l2m, 
                      l3m};\[IndentingNewLine]\[IndentingNewLine]]; \
\[IndentingNewLine]stretches\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine] (*\ 
              experimental\ data\ sets\ *) \[IndentingNewLine]error\  = \ 
              0.0; \[IndentingNewLine] (*\ \(datasets = {"\<nt02b-cycC\>"};\)\
\ *) \[IndentingNewLine]datasets = {"\<is01b-creep\>"}; \
\[IndentingNewLine]For[i = 1, 
              i <= Length[datasets], \(i++\), \[IndentingNewLine]If[errchk, \ 
                Print[datasets[\([i]\)]]]; \[IndentingNewLine]stream\  = \ 
                OpenRead[datasets[\([i]\)]]; \[IndentingNewLine]header = \ 
                Read[stream, String]; \[IndentingNewLine]data = 
                ReadList[
                  stream, {Number, Number, Number, Number, Number, 
                    Number}]; \[IndentingNewLine]Close[
                stream]; \[IndentingNewLine]data\  = \ Drop[data, 4]; \  (*\ 
                oddness\ in\ first\ samples\ *) \[IndentingNewLine]time0 = \ 
                First[\ Part[Transpose[data], 
                    2]]; \[IndentingNewLine]expTime = \ 
                Part[Transpose[data], 2] - time0; \[IndentingNewLine]edts = 
                Drop[RotateLeft[expTime] - 
                    expTime, \(-1\)]; \[IndentingNewLine]expStress\  = \ 
                Part[Transpose[data], 5]; \[IndentingNewLine]expStress\  *= \ 
                
                StressScale; \[IndentingNewLine]\[IndentingNewLine]expStrain \
= \ 1.0 + Part[Transpose[data], 6]; \  (*\ ?? \(?\ 
                    is\ this\ right\)\ *) \n\[IndentingNewLine]Interpolate[
                  th_, thB_, yhB_]\  := \ 
                Module[{t1, t2, y1, y2, j = 1, t, y, 
                    yh = {}}, \[IndentingNewLine]t1 = thB[\([j]\)]; 
                  t2 = thB[\([j + 1]\)]; y1 = yhB[\([j]\)]; 
                  y2 = yhB[\([j + 1]\)]; \[IndentingNewLine]For[i = 1, 
                    i \[LessEqual] 
                      Length[th], \(i++\), \[IndentingNewLine]t = 
                      th[\([i]\)]; \[IndentingNewLine]While[t > t2, \(j++\); 
                      t1 = thB[\([j]\)]; t2 = thB[\([j + 1]\)]; 
                      y1 = yhB[\([j]\)]; 
                      y2 = yhB[\([j + 1]\)]]; \[IndentingNewLine]AppendTo[yh, 
                      y = y1 + \((y2 - 
                                y1)\)*\((t - t1)\)/\((t2 - 
                                  t1)\)];\[IndentingNewLine]]; \
\[IndentingNewLine]yh\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]dt = 1.0; \  (*\ try\ coarse\ timestep, \ 
                was\ 0.1\ *) \[IndentingNewLine]th\  = \ 
                Range[First[expTime], Last[expTime], 
                  dt]; \[IndentingNewLine]eshA = 
                Interpolate[th, expTime, 
                  expStress]; \[IndentingNewLine]Th = \ 
                Transpose[{0*th, eshA, 
                    0*th}]; \[IndentingNewLine]\[IndentingNewLine]lh\  = 
                strainHistory[dt, 
                  Th]; \[IndentingNewLine]\[IndentingNewLine] (*\ 
                file\ output\ *) \[IndentingNewLine]data = 
                Transpose[{th, Part[Transpose[lh], 1], 
                    Part[Transpose[lh], 2], 
                    Part[Transpose[lh], 
                      2]}]; \[IndentingNewLine]Export["\<strain.dat\>", 
                data]; \[IndentingNewLine]\[IndentingNewLine] (*\ 
                L2\ error\ *) \[IndentingNewLine]intStrain = 
                Interpolate[th, expTime, 
                  expStrain]; \ \[IndentingNewLine]l2h\  = \ 
                Part[Transpose[lh], 2]; \[IndentingNewLine]diff\  = \ 
                l2h - intStrain; \[IndentingNewLine]error\  += \ 
                dt*Sqrt[diff . diff]; \  (*\ 
                Sqrt\ \(\(after\)\(?\)\)\ *) \[IndentingNewLine]\
\[IndentingNewLine]If[
                errchk, \[IndentingNewLine]RGB\  = \ {RGBColor[1, 0, 0], 
                    RGBColor[0, 1, 0], 
                    RGBColor[0, 0, 
                      1]}; \[IndentingNewLine]Show[\[IndentingNewLine]pls = 
                    Table[\[IndentingNewLine]ListPlot[
                        Transpose[{th, Part[Transpose[lh], i]}], 
                        PlotJoined \[Rule] True, 
                        PlotLabel \[Rule] "\<strain history\>", 
                        PlotRange \[Rule] All, 
                        PlotStyle \[Rule] 
                          RGB[\([i]\)]], \ \[IndentingNewLine]{i, 
                        3}], \[IndentingNewLine]ListPlot[
                    Transpose[{expTime, 
                        expStrain}]]\[IndentingNewLine]];\[IndentingNewLine]];\
\[IndentingNewLine]]; \[IndentingNewLine]If[errchk, 
              Export["\<results.dat\>", {error}]]; \[IndentingNewLine]Return[
              error], \[IndentingNewLine]60*5, \  (*\ 
              max\ allowed\ time\ *) \[IndentingNewLine]Return[
              1.0]\  (*dummy\ error\ value*) \[IndentingNewLine]]\
\[IndentingNewLine]];\)\)\)\)], "Input"],

Cell[BoxData[
    \(\(\( (*\ 
      DELETE\ THIS\ FOR\ OPTIMIZATION\ *) \)\(\[IndentingNewLine]\)\(\
\[IndentingNewLine]\)\(\(stream\  = \ 
        OpenRead["\<test.in\>"];\)\[IndentingNewLine]
    \(header = \ Read[stream, String];\)\[IndentingNewLine]
    \(parameters = {};\)\[IndentingNewLine]
    \(For[i = 1, 
        i < 7, \(i++\), \[IndentingNewLine]{data, junk} = 
          Read[stream, {Number, String}]; \[IndentingNewLine]AppendTo[
          parameters, data];\[IndentingNewLine]];\)\[IndentingNewLine]
    \(Close[stream];\)\[IndentingNewLine]
    \(Print[parameters];\)\[IndentingNewLine]
    \(error = 
        compare[parameters[\([1]\)], parameters[\([2]\)], 
          parameters[\([3]\)], parameters[\([4]\)], parameters[\([5]\)], 
          parameters[\([6]\)]];\)\[IndentingNewLine]
    \(Print[error];\)\[IndentingNewLine]\[IndentingNewLine] (*\ 
      for\ "\<nt02b-cycC\>"\[IndentingNewLine]6\ variables\ 1\ functions\n
          0.6000000000  e + 03\ alpha\n2.0000000000  e + 
        00\ beta\n2.9000000000  e + 
        03\ mu\n1.0000000000  
          e + \(00\ taulo\)\n\(3.0000000000  e + 
            00\ taudif\)\n\(0.2000000000  e + 00\ c\)\n1\ ASV_  
          1\n*) \[IndentingNewLine]\[IndentingNewLine]
    \)\)\)], "Input"]
},
FrontEndVersion->"5.0 for X",
ScreenRectangle->{{0, 1400}, {0, 1050}},
CellGrouping->Manual,
WindowSize->{873, 945},
WindowMargins->{{Automatic, 227}, {Automatic, 12}},
PrintingPageRange->{Automatic, Automatic},
PrintingOptions->{"PaperSize"->{612, 792},
"PaperOrientation"->"Portrait",
"PostScriptOutputFile":>FrontEnd`FileName[{$RootDirectory, "home", "rjones", \
"Mathematica", "FiberAnisotropy"}, "QuasilinearVE.nb.ps", CharacterEncoding \
-> "iso8859-1"],
"Magnification"->1}
]

(*******************************************************************
Cached data follows.  If you edit this Notebook file directly, not
using Mathematica, you must remove the line containing CacheID at
the top of  the file.  The cache data will then be recreated when
you save this file from within Mathematica.
*******************************************************************)

(*CellTagsOutline
CellTagsIndex->{}
*)

(*CellTagsIndex
CellTagsIndex->{}
*)

(*NotebookFileOutline
Notebook[{
Cell[1754, 51, 16830, 291, 3595, "Input"],
Cell[18587, 344, 1263, 25, 443, "Input"]
}
]
*)



(*******************************************************************
End of Mathematica Notebook file.
*******************************************************************)

