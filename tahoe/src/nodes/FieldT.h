/* $Id: FieldT.h,v 1.1.2.2 2002-04-23 01:25:51 paklein Exp $ */

#ifndef _FIELD_T_H_
#define _FIELD_T_H_

/* direct members */
#include "iArrayT.h"
#include "dArrayT.h"
#include "dArray2DT.h"
#include "iArray2DT.h"
#include "StringT.h"
#include "IC_CardT.h"
#include "KBC_CardT.h"
#include "FBC_CardT.h"
#include "pArrayT.h"
#include "GlobalT.h"

/* forward declarations */
class LocalArrayT;
class nControllerT;
class KBC_ControllerT;
class FBC_ControllerT;
template <class TYPE> class RaggedArray2DT;
template <class TYPE> class AutoArrayT;
class ifstreamT;
class ofstreamT;
class FieldSupportT;

/** field of unknowns */
class FieldT
{
public:

	/** inactive equation number codes */
	enum EquationCodeT {
	          kInit = 0, /**< uninitialized equation number */
		kPrescribed =-1, /**< dof has prescribed value */ 
	      kExternal =-2  /**< node is external */ };
	
	/** constructor */
	FieldT(const StringT& name, nControllerT& controller, int ndof);

	/** \name initialization */
	/*@{*/
	/** set field labels */
	void SetLabels(const ArrayT<StringT>& labels);

	/** set number of nodes. Allocates memory. */
	void Dimension(int nnd);

	/** register the local array with its source */
	void RegisterLocal(LocalArrayT& array) const;

	/** set the group number */
	void SetGroup(int group) { fGroup = group; };	
	/*@}*/
	
	/** \name accessors */
	/*@{*/
	/** field name */
	const StringT& Name(void) const { return fName; };

	/** set the group number */
	int Group(void) { return fGroup; };	
	
	/** time integrator */
	nControllerT& nController(void) { return fnController; };
	
	/** the field labels */
	const ArrayT<StringT>& Labels(void) const { return fLabels; };

	/** the specified derivative of the field */ 
	const dArray2DT& Field(int order) const { return fField[order]; };
	
	/** number of nodes */
	int NumNodes(void) const { return fEqnos.MajorDim(); };
	
	/** number of degrees of freedom per node */
	int NumDOF(void) const { return fEqnos.MinorDim(); };
	
	/** number of time derivatives stored by the field */
	int Order(void) const { return fField.Length(); };

	/** append connectivities generated by the KBC_ControllerT's and
	 * FBC_ControllerT's. */
	void Connectivities(AutoArrayT<const iArray2DT*>& connects_1,
		AutoArrayT<const RaggedArray2DT<int>*>& connects_2) const;

	/** return the GlobalT::SystemTypeT for the all the fields in the
	 * specified group */
	GlobalT::SystemTypeT SystemType(void) const;
	/*@}*/

	/** \name time integration */
	/*@{*/
	/** beginning of time series */
	void InitialCondition(void);
	
	/** apply predictor to all degrees of freedom */
	void InitStep(void);

	/** assemble contributions to the residual */
	void FormRHS(const FieldSupportT& support);

	/** assemble contributions to the tangent */
	void FormLHS(const FieldSupportT& support);

	/** update the active degrees of freedom */
	void Update(const dArrayT& update, int eq_start, int num_eq);
	
	/** check for relaxation */
	GlobalT::RelaxCodeT RelaxSystem(void);

	/** update history */
	void CloseStep(void);

	/** reset displacements (and configuration to the last known solution) */
	void ResetStep(void);
	/*@}*/

	/** \name equation numbers */
	/*@{*/
	/** determine the number of equations for the field */
	int NumEquations(void) const;
	
	/** the global equation numbers array. Resets the cached count of active equations */
	iArray2DT& Equations(void);
	
	/** const access to the equation numbers */
	const iArray2DT& Equations(void) const { return fEqnos; };

	/** append the equation sets generated by the field. These include sets
	 * generated by the KBC_ControllerT's and FBC_ControllerT's. This call
	 * signals to the field that FieldT::Equations has been filled with
	 * up to date equation numbers. */
	void EquationSets(AutoArrayT<const iArray2DT*>& eq_1, 
		AutoArrayT<const RaggedArray2DT<int>*>& eq_2);

	/** mark prescribed equations. Prescribed values are marked first
	 * using the nodally prescribed kinematic boundary conditions
	 * followed by the KBC_ControllerT's. Equation numbers for prescribed
	 * values will be < 0. */
	void MarkPrescribedEquations(void);

	/** collect equation numbers.
	 * \param nodes element connectivities: [nel] x [nen]
	 * \param eqnos destination for equation numbers: [nel] x [nen*ndof] */
	void SetLocalEqnos(const iArray2DT& nodes, iArray2DT& eqnos) const;

	/** collect equation numbers. Connectivities are passed in a RaggedArray2DT, 
	 * which allows an arbitrary number of nodes per element.
	 * \param nodes element connectivities: [nel] x [nen_i]
	 * \param eqnos destination for equation numbers: [nel] x [nen_i*ndof] */
	void SetLocalEqnos(const RaggedArray2DT<int>& nodes, RaggedArray2DT<int>& eqnos) const;

	/** collect equation numbers */
	void SetLocalEqnos(const iArrayT& tags, iArray2DT& eqnos) const;
	/*@}*/

	/** \name restart functions
	 * The restart functions should read/write any data that overrides the
	 * default values */
	/*@{*/ 
	void ReadRestart(ifstreamT& in);
	void WriteRestart(ofstreamT& out) const;
	/*@}*/ 

	/** \name output */
	/*@{*/
	/** write field equation numbers to the output stream */
	void WriteEquationNumbers(ostream& out, const iArrayT* node_map) const;

	/** write output data */
	void WriteOutput(ostream& out) const;
	/*@}*/

	/** \name "ghost" node data */
	/*@{*/
	/** active/prescribed flags for "ghost" nodes */
	iArray2DT& ExternalEquations(void) { return fExEqnos; };

	/** space for the update for "ghost" nodes */
	dArray2DT& ExternalUpdate(void) { return fExUpdate; };
	/*@}*/

private:

	/** apply the IC_CardT to the field */
	void Apply_IC(const IC_CardT& card);

	/** mark global equations with the specified BC */
	void SetBCCode(const KBC_CardT& card);

	/** determine the destinations for the force boundary conditions */
	void SetFBCEquations(void);

private:

	/** name */
	StringT fName;
	
	/** solution set number */
	int fGroup;

	/** time integrator */
	nControllerT& fnController;
	
	/** the field [nderiv]: [nnd] x [ndof] */
	ArrayT<dArray2DT> fField;

	/** field history */
	ArrayT<dArray2DT> fField_last;

	/** \name equation numbers */
	/*@{*/
	/** equation array: [nnd] x [ndof] */
	iArray2DT fEqnos;

	/** (cached) count of the number of active equations */
	int fNumActiveEquations;
	/*@{*/
	
	/** field dof labels [ndof] */
	ArrayT<StringT> fLabels;
	
	/** \name initial and kinematic boundary conditions */
	/*@{*/
	/** initial conditions */
	ArrayT<IC_CardT> fIC;
	  	
	/** kinematic boundary conditions */
	ArrayT<KBC_CardT> fKBC;

	/** special KBC objects */
	pArrayT<KBC_ControllerT*> fKBC_Controllers;
	/*@}*/

	/** \name force boundary conditions */
	/*@{*/
	/** nodal forces */
	ArrayT<FBC_CardT> fFBC;

	/** force vector */
	dArrayT fFBCValues;

	/** equations with applied forces */
	iArrayT fFBCEqnos;

	/** special FBC objects */
	pArrayT<FBC_ControllerT*> fFBC_Controllers;
	/*@}*/
	
	/** \name "ghost" node work space */
	/*@{*/
	/** free/prescribed ghost node equations */
	iArray2DT fExEqnos;	

	/** communication buffer */
	dArray2DT fExUpdate;
	/*@}*/
};

/* inlines */
inline void FieldT::SetLocalEqnos(const iArrayT& tags,
	iArray2DT& eqnos) const
{
	eqnos.RowCollect(tags,fEqnos);
}

/* the global equation numbers array. Resets the cached count of active equations */
inline iArray2DT& FieldT::Equations(void)
{
	fNumActiveEquations = -1;
	return fEqnos;
}

/* determine the number of equations for the field */
int FieldT::NumEquations(void) const
{
	/* recalculate */
	if (fNumActiveEquations == -1)
	{
		int neq = 0;
		int *peq = fEqnos.Pointer();
		int len  = fEqnos.Length();
		for (int i = 0; i < len; i++)
			if (*peq++ > 0) neq++;
	
		/* not so const */
		const_cast<FieldT*>(this)->fNumActiveEquations = neq;
	}
	return fNumActiveEquations;
}

#endif /* _FIELD_T_H_ */
