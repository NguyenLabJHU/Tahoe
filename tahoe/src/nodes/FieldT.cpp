/* $Id: FieldT.cpp,v 1.1.2.1 2002-04-22 07:06:05 paklein Exp $ */
#include "FieldT.h"
#include "fstreamT.h"
#include "nControllerT.h"
#include "KBC_ControllerT.h"
#include "FBC_ControllerT.h"
#include "RaggedArray2DT.h"
#include "LocalArrayT.h"

/* constructor */
FieldT::FieldT(const StringT& name, nControllerT& controller, int ndof):
	fName(name),
	fGroup(0),
	fnController(controller),
	fField(fnController.Order()),
	fField_last(fnController.Order()),
	fEqnos(0, ndof)
{
	/* set default labels */
	fLabels.Dimension(ndof);
	for (int i = 0; i < fLabels.Length(); i++)
		fLabels[i].Append("D_", i+1);
		
	/* set integrator */
	for (int i = 0; i < fField.Length(); i++)
		fnController.RegisterField(fField[i], i);
}

/* set field labels */
void FieldT::SetLabels(const ArrayT<StringT>& labels)
{
	fLabels = labels;
}

/* set number of nodes */
void FieldT::Dimension(int nnd)
{
	/* number of degrees of freedom */
	int ndof = fEqnos.MinorDim();

	/* dimension field */
	for (int i = 0; i < fField.Length(); i++)
	{
		fField[i].Dimension(nnd, ndof);
		fField_last[i].Dimension(fField[i]);
	}

	/* dimension equations array */
	fEqnos.Dimension(nnd, ndof);
}

/* set the number of external nodes. Dimensions work space for external nodes */
void FieldT::DimensionExternal(int nnd)
{
	/* number of degrees of freedom */
	int ndof = fEqnos.MinorDim();

	/* dimension */
	fExEqnos.Dimension(nnd, ndof);
	fExUpdate.Dimension(nnd, ndof);
}

void FieldT::RegisterLocal(LocalArrayT& array) const	
{
	switch (array.Type())
	{
		case LocalArrayT::kDisp:
			array.SetGlobal(fField[0]);
			break;			
		case LocalArrayT::kVel:
		{
			if (Order() < 1) {
				cout << "\n FieldT::RegisterLocal: only up to order " << Order() << ": 1" << endl;
				throw eGeneralFail;
			}
			array.SetGlobal(fField[1]);
			break;			
		}
		case LocalArrayT::kAcc:
		{
			if (Order() < 2) {
				cout << "\n FieldT::RegisterLocal: only up to order " << Order() << ": 2" << endl;
				throw eGeneralFail;
			}
			array.SetGlobal(fField[2]);
			break;			
		}
		case LocalArrayT::kLastDisp:
			array.SetGlobal(fField_last[0]);
			break;			
		case LocalArrayT::kLastVel:
		{
			if (Order() < 1) {
				cout << "\n FieldT::RegisterLocal: only up to order " << Order() << ": 1" << endl;
				throw eGeneralFail;
			}
			array.SetGlobal(fField_last[1]);
			break;			
		}
		case LocalArrayT::kLastAcc:
		{
			if (Order() < 2) {
				cout << "\n FieldT::RegisterLocal: only up to order " << Order() << ": 2" << endl;
				throw eGeneralFail;
			}
			array.SetGlobal(fField_last[2]);
			break;			
		}
		default:
			cout << "\n FieldT::RegisterLocal: unrecognized type: " << array.Type() << endl;
			throw eGeneralFail;
	}
}

/* beginning of time series */
void FieldT::InitialCondition(void)
{
	/* initial fields */
	for (int i = 0; i < fField.Length(); i++)
		fField[i] = 0.0;

	/* apply initial cards */
	for (int i = 0; i < fIC.Length(); i++)
		Apply_IC(fIC[i]);

	/* KBC controllers */
	for (int k = 0; k < fKBC_Controllers.Length(); k++)
		fKBC_Controllers[k]->InitialCondition();

	/* FBC controllers */
	for (int i = 0; i < fFBC_Controllers.Length(); i++)
		fFBC_Controllers[i]->InitialCondition();

	/* initial history */
	fField_last = fField;
}

/* apply predictor to all degrees of freedom */
void FieldT::InitStep(void)
{
	/* predictor to all DOF's */
	fnController.Predictor();

	/* KBC controllers */
	for (int i = 0; i < fKBC_Controllers.Length(); i++)
		fKBC_Controllers[i]->InitStep();

	/* FBC controllers */
	for (int j = 0; j < fFBC_Controllers.Length(); j++)
		fFBC_Controllers[j]->InitStep();

	/* apply KBC cards */
	for (int i = 0; i < fKBC.Length(); i++)
		fnController.ConsistentKBC(fKBC[i]);
		
	/* apply KBC cards generated by KBC controllers */
	for (int j = 0; j < fKBC_Controllers.Length(); j++)
	{
		/* cards */
		const ArrayT<KBC_CardT>& cards = fKBC_Controllers[j]->KBC_Cards();

		/* apply KBC cards */
		for (int i = 0; i < cards.Length(); i++)
			fnController.ConsistentKBC(cards[i]);
	}
}

/* update history */
void FieldT::CloseStep(void)
{

}

/* update the active degrees of freedom */
void FieldT::Update(const dArrayT& update, int eq_start, int eq_stop)
{
	/* corrector */
	fnController.Corrector(fEqnos, update, eq_start, eq_stop);
}

/* reset displacements (and configuration to the last known solution) */
void FieldT::ResetStep(void)
{
	/* reset field */
	fField = fField_last;

	/* KBC controllers */
	for (int j = 0; j < fKBC_Controllers.Length(); j++)
		fKBC_Controllers[j]->Reset();

	/* FBC controllers */
	for (int i = 0; i < fFBC_Controllers.Length(); i++)
		fFBC_Controllers[i]->Reset();
}

/* Collect the local element lists */
void FieldT::SetLocalEqnos(const iArray2DT& nodes, iArray2DT& eqnos) const
{
/* consistency checks */
#if __option (extended_errorcheck)
	if (nodes.MajorDim() != eqnos.MajorDim() ||
	    eqnos.MinorDim() < nodes.MinorDim()*NumDOF()) throw eGeneralFail;
		//must have enough space (and maybe more)
#endif

	int numel = nodes.MajorDim();
	int nen   = nodes.MinorDim();
	int ndof  = NumDOF();
	for (int i = 0; i < numel; i++)
	{
		int* pnodes = nodes(i);
		int* pien   = eqnos(i);
		for (int j = 0; j < nen; j++)
		{
			int nodenum = *pnodes++;
			for (int k = 0; k < ndof; k++)
				*pien++ = fEqnos(nodenum, k);
		}
	}
}

void FieldT::SetLocalEqnos(const RaggedArray2DT<int>& nodes,
	RaggedArray2DT<int>& eqnos) const
{
/* consistency checks */
#if __option(extended_errorcheck)
	if (nodes.MajorDim() != eqnos.MajorDim()) throw eSizeMismatch;
#endif
	
	int numel = nodes.MajorDim();
	for (int i = 0; i < numel; i++)
	{
#if __option(extended_errorcheck)
		if (eqnos.MinorDim(i) < nodes.MinorDim(i)*NumDOF()) throw eSizeMismatch;
		//must have enough space (and maybe more)
#endif
		int  nen    = nodes.MinorDim(i);
		int* pnodes = nodes(i);
		int* pien   = eqnos(i);
		int ndof    = NumDOF();
		for (int j = 0; j < nen; j++)
		{
			int nodenum = *pnodes++;
			for (int k = 0; k < ndof; k++)
				*pien++ = fEqnos(nodenum, k);
		}
	}
}

void FieldT::ReadRestart(ifstreamT& in)
{
	/* external file */
	StringT file;
	ifstreamT u_in;

	/* read fields */
	StringT deriv;
	for (int i = 0; i < fField.Length(); i++)
	{
		/* file name */
		StringT file = in.filename();
		file.Append(".", fName);
		file.Append(".", deriv, "u");

		/* read */
		u_in.open(file);
		if (u_in.is_open()) 
		{
			u_in >> fField[i];
			u_in.close();
		} 
		else 
		{
			cout << "\n FieldT::ReadRestart: file not found: " 
                 << file << '\n' <<   "     assuming order " << i << " = 0.0" << endl;
			fField[i] = 0.0;
		}

		/* next */
		deriv.Append("D");
	}

	/* KBC controllers */
	for (int j = 0; j < fKBC_Controllers.Length(); j++)
		fKBC_Controllers[j]->ReadRestart(in);

	/* FBC controllers */
	for (int i = 0; i < fFBC_Controllers.Length(); i++)
		fFBC_Controllers[i]->ReadRestart(in);
}

void FieldT::WriteRestart(ofstreamT& out) const
{
	/* external file */
	ofstreamT u_out;
	u_out.precision(out.precision());

	/* write field */
	StringT deriv;
	for (int i = 0; i < fField.Length(); i++)
	{
		/* file name */
		StringT file = out.filename();
		file.Append(".", fName);
		file.Append(".", deriv, "u");

		/* write */
		u_out.open(file);
		u_out << fField[i] << '\n';
		u_out.close();
	
		/* next */
		deriv.Append("D");
	}

	/* KBC controllers */
	for (int j = 0; j < fKBC_Controllers.Length(); j++)
		fKBC_Controllers[j]->WriteRestart(out);

	/* FBC controllers */
	for (int i = 0; i < fFBC_Controllers.Length(); i++)
		fFBC_Controllers[i]->WriteRestart(out);
}

void FieldT::WriteEquationNumbers(ostream& out, const iArrayT* node_map) const
{
	/* dimensions */
	int nnd  = NumNodes();
	int ndof = NumDOF();
	int columns = 1;
	
	/* print header */
	out << "\n Field: \"" << fName << "\"\n\n";
	for (int k = 0; k < columns; k++)
	{
		out << setw(kIntWidth) << "node";
		for (int j = 0; j < ndof; j++)
		{
			out << setw(kIntWidth - 2) << "d[";
			out << j+1 << "]";
		}
		out << "    ";
	}
	out << "\n\n";

	/* print data */
	int colcount = 0;
	for (int i = 0; i < nnd; i++)
	{
		out << setw(kIntWidth) << ((node_map != NULL) ? (*node_map)[i]: i) + 1;
		for (int j = 0; j < nnd; j++)
			out << setw(kIntWidth) << fEqnos(i,j);
			
		/* wrap */
		if (++colcount == columns)
		{
			out << '\n';
			colcount = 0;
		}
		else
			out << "    ";	
	}
	
	if (colcount != 0) out << '\n'; //terminate mid-line
	out << '\n';
}

/**********************************************************************
 * Private
 **********************************************************************/

void FieldT::Apply_IC(const IC_CardT& card)
{
	/* check order */
	if (card.Order() > Order()) {
		cout << "\n FieldT::Apply_IC: order is out of range {0," 
		     << Order() << "}: " << card.Order() << endl;
		throw eOutOfRange;
	}	

	/* decode */
	int node     = card.Node();
	int dof      = card.DOF();
	double value = card.Value();

	/* set */
	dArray2DT& field = fField[card.Order()];
	if (node == -1)
		field.SetColumn(dof, value);
	else
		field(node, dof) = value;
}

