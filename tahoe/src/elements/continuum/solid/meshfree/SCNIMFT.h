/* $Id: SCNIMFT.h,v 1.25 2005-01-19 08:59:25 paklein Exp $ */
#ifndef _SCNIMF_T_H_
#define _SCNIMF_T_H_

/* base class */
#include "ElementBaseT.h"

/* direct members */
#include "VariArrayT.h"
#include "LocalArrayT.h"
#include "MeshFreeNodalShapeFunctionT.h"
#include "MaterialListT.h"
#include "nVariArray2DT.h"
#include "InverseMapT.h"
#include "iArrayT.h"
#include "iArray2DT.h"
#include "dArrayT.h"
#include "dArray2DT.h"
#include "RaggedArray2DT.h"
#include "GeometryBaseT.h"
#include "ScheduleT.h"
#include "LinkedListT.h"

#ifdef __QHULL__
#include "CompGeomT.h"
#endif

namespace Tahoe {

/** forward declarations */
class iGridManagerT;
class CommManagerT;
class dSPMatrixT; //TEMP
class InverseMapT;
class ifstreamT;
class ofstreamT;
class MeshFreeSupportT;
class Traction_CardT;

/** base class for particle types */
class SCNIMFT: public ElementBaseT
{
public:

	/** constructor */
	SCNIMFT(const ElementSupportT& support, const FieldT& field);
	SCNIMFT(const ElementSupportT& support);

	/** destructor */
	~SCNIMFT(void);
	
	/** form of tangent matrix */
	virtual GlobalT::SystemTypeT TangentType(void) const;

	/** NOT implemented. Returns an zero force vector */
	virtual void AddNodalForce(const FieldT& field, int node, dArrayT& force);
			
	/** returns the energy as defined by the derived class types */
	virtual double InternalEnergy(void) { return 0.0; };
	
	/** resgiter for writing output. Uses output labels generated by 
	 * small- and finite- strain implementations of this base class.
	 */
	virtual void RegisterOutput(void);

	/** write output. ParticleT::WriteOutput only writes search grid statistics.
	 * Sub-classes are responsible for writing data for each particle, given the
	 * variables names returned by ParticleT::GenerateOutputLabels. */
	virtual void WriteOutput(void);

	/* compute specified output parameter and send for smoothing */
	virtual void SendOutput(int kincode);

	/** trigger reconfiguration */
	virtual GlobalT::RelaxCodeT RelaxSystem(void);

	/** DOF's are not interpolants of the nodal values */
	virtual int InterpolantDOFs(void) const { return 0; };

	/** construct field */
	virtual void NodalDOFs(const iArrayT& nodes, dArray2DT& DOFs) const;

	/** \name restart functions */
	/*@{*/
	/** write restart data to the output stream. Should be paired with
	 * the corresponding ElementBaseT::ReadRestart implementation. */
	virtual void WriteRestart(ostream& out) const;

	/** read restart data to the output stream. Should be paired with
	 * the corresponding ElementBaseT::WriteRestart implementation. */
	virtual void ReadRestart(istream& in);
	/*@}*/

	/** Loop over nodes and compute stiffness matrix */
	virtual void LHSDriver(GlobalT::SystemTypeT sys_type) = 0;
	
	/** Loop over nodes and compute internal force */
	virtual void RHSDriver(void);
	
	/** Generate local equation numbers */
	virtual void Equations(AutoArrayT<const iArray2DT*>& eq_1,
						AutoArrayT<const RaggedArray2DT<int>*>& eq_2);

	/** \name communication routine for MFLagMultT
	/*@{*/
	/** Translate global node numbers to local ones,
	 * returns 0 if unsucessful, i.e. nodes not contained in fNodes */
	int GlobalToLocalNumbering(iArrayT& nodes) const;
	
	/** Translate global node numbers to local ones */
	int GlobalToLocalNumbering(RaggedArray2DT<int>& nodes);

	/** Return interpolated displacement field at selected nodes */
	void InterpolatedFieldAtNodes(const iArrayT& nodes, dArray2DT& fieldAtNodes) const;

	/** Return the data structure holding the supports of the localNodes and their window function values */
	void NodalSupportAndPhi(const iArrayT& localNodes, RaggedArray2DT<int>& support, 
		RaggedArray2DT<double>& phi) const;
	
	int SupportSize(int localNode) const;
	/*@}*/

	/** \name types needed for the Voronoi diagram calculation */
	/*@{*/
#ifndef __QHULL__
	/** Basic structure -- hullMap[i][j] gives index of jth vertex of structure i */
        typedef ArrayT<iArrayT> ConvexHullMap;

        /** Voronoi diagram facet structure is an array of convex hulls  */
        typedef ArrayT< ConvexHullMap > VoronoiDiagramMap;
#endif
	/*@}*/
	
	/** \name implementation of the ParameterInterfaceT interface */
	/*@{*/
	/** describe the parameters needed by the interface */
	virtual void DefineParameters(ParameterListT& list) const;

	/** information about subordinate parameter lists */
	virtual void DefineSubs(SubListT& sub_list) const;

	/** return the description of the given inline subordinate parameter list */
	virtual void DefineInlineSub(const StringT& name, ParameterListT::ListOrderT& order, 
		SubListT& sub_lists) const;

	/** a pointer to the ParameterInterfaceT of the given subordinate */
	virtual ParameterInterfaceT* NewSub(const StringT& name) const;
	
	virtual void TakeParameterList(const ParameterListT& list);
	
	void TakeNaturalBC(const ParameterListT& list);
	/*@}*/


protected: /* for derived classes only */

	/** echo element connectivity data. Reads parameters that define
	 * which nodes belong to this ParticleT group. */
	virtual void DefineElements(const ArrayT<StringT>& block_ID, const ArrayT<int>& mat_index);
	
	virtual void CollectMaterialInfo(const ParameterListT& all_params, ParameterListT& mat_params) const = 0;
	virtual MaterialListT* NewMaterialList(const StringT& name, int size) = 0;
	
	/** generate labels for output data */
	virtual void GenerateOutputLabels(ArrayT<StringT>& labels);

	/** return true if connectivities are changing */
	virtual bool ChangingGeometry(void) const;

	/** assemble particle mass matrix into LHS of global equation system */
	virtual void AssembleParticleMass(const double rho);

	/** transfers data from QHULL and computes new data structures. This function 
		initializes fNonDeloneEdges, fNonDeloneNormals, fSelfDualFacets, fBoundaryIntegrationWeights,
		and fVoronoiCellCentroids. If qhull is not used, these data structures are
		read in by VoronoiDiagramFromFile */
	void InitializeVoronoiData(void);
	
	/** compute B matrices for strain smoothing/nodal integration */
	virtual void ComputeBMatrices(void);
	
	/** write out Voronoi diagram data. This function is only called when qhull is used
		to compute the clipped Voronoi diagram. */
	void VoronoiDiagramToFile(ofstreamT& vout);
	
	/** read in Voronoi diagram data. This function reads in data structures when qhull
		is not used to create them. It initializes fVoronoiVertices, fVoronoiCellVolumes,
		fDeloneEdges, fDualFacets, fNonDeloneEdges, fNonDeloneNormals, fSelfDualFacets, 
		fBoundaryIntegrationWeights, and fVoronoiCellCentroids. If qhull is used, these
		data structures are either gotten directly from qhull or created in 
		InitializeVoronoiData. */
	void VoronoiDiagramFromFile(ifstreamT& vin);
	
protected:

	MeshFreeSupportT* fMFSupport;
	
	/** pointer to list parameters needed to construct shape functions */
	const ParameterListT* fMeshfreeParameters;

	/** reference ID for sending output */
	int fOutputID;
	
	/** connectivities used to define the output set. */
	iArray2DT fPointConnectivities;

	/** \name cached RHS workspace */
	/*@{*/
	dArray2DT fForce;
	nVariArray2DT<double> fForce_man;
	/*@}*/
	
	/** spatial dimensionality */
	int fSD;

	/** indices of nodes */
	iArrayT fNodes;
	/** the coordinates of the nodes */
	dArray2DT fDeloneVertices;
	
	/** \name Data Structures for Voronoi Decomposition */
	/*@{*/
	
	/** these are dual to Voronoi facets. They have minor dimension of 2 . 
	     Difference in the two points is parallel to the normal vector of the 
	     Voronoi facet dual to the Delone edge. This data structure is created
	     by qhull or read in from a text file. */
	iArray2DT fDeloneEdges;

	/** Voronoi facets dual to the Delone Edges -- This data structure is currently
		a list of vertices of the facets. In 2D, all facets are simplicial and this
		is fine. In 3D, it will change. */
	RaggedArray2DT<int> fDualFacets; 
	
	/** boundary facets. See qhull/CompGeomT.h for a definition of the self-dual
		terminology -- this data structure is 
		created in InitializeVoronoiData based on qhull's clipped Voronoi diagram. It is then
		written to the geometry text file. This is essentially a flattened version of
		qhulls selfDual data structure */
	iArray2DT fSelfDualFacets; 

	/** connectivity of boundary nodes. Currently determined from an underlying 
	    element connectivity */
	iArray2DT fBoundaryConnectivity; 
	
	/** union of nodes in fBoundaryConnectivity */
	iArrayT fBoundaryNodes; 
	
	/** true if boundary connectivity is simplicial */
	bool fBoundaryIsTriangulated; 
	
	/** additional edges associated only with one node -- this data structure is 
		created in InitializeVoronoiData based on qhull's clipped Voronoi diagram. It is then
		written to the geometry text file. Since these facets are self dual, there is only
		one Delone vertex per facet, and this vertex is the boundary vertex. The list of
		boundary vertices for each self-dual facet is contained in this array of integers. */
	iArrayT fNonDeloneEdges; 
	
	/** normal vectors of the facets for those edges -- this data structure is 
		created in InitializeVoronoiData based on qhull's clipped Voronoi diagram. It is then
		written to the geometry text file.*/
	dArray2DT fNonDeloneNormals;
	
	/** areas of boundary facets -- this data structure is 
		created in InitializeVoronoiData based on qhull's clipped Voronoi diagram. It is then
		written to the geometry text file. */
	dArrayT fBoundaryIntegrationWeights;

	/** Compute or read the Voronoi Diagram -- these data structures are created by qhull */	
#ifdef __QHULL__	
	CompGeomT* fVoronoi;
#else
	void* fVoronoi;
#endif
	bool qComputeVoronoiCell, qJustVoronoiDiagram;
	StringT vCellFile;
	
	int fNumIP;

	/** Volume associated with each node -- integration weight for nodal integration */
	dArrayT fVoronoiCellVolumes;
	/** The coordinates of the Voronoi diagram after it has been clipped by the body boundary */
	dArray2DT fVoronoiVertices; 
	/** The centroids of the clipped Voronoi cells. This data structure is created in 
		InitializeVoronoiData or read in from a text file. The centroids are used to 
		compute the mass matrix for the axisymmetric element. */
	dArray2DT fVoronoiCellCentroids;
	/*@}*/

	/** list of materials */
	MaterialListT* fMaterialList;
	
	/** workspaces for strain smoothing */
	ArrayT< LinkedListT<int> > nodeWorkSpace; // should be local?
	ArrayT< LinkedListT<dArrayT> > facetWorkSpace; // should be local?

	/** These are the actual data structures used for force and stiffness computations */
	RaggedArray2DT<int> nodalCellSupports;
	RaggedArray2DT<dArrayT> bVectorArray;
	
	/** workspace for nodal shape functions */
	RaggedArray2DT<double> fNodalPhi, fBoundaryPhi;
	RaggedArray2DT<int> fNodalSupports, fBoundarySupports;
	  	
	/* body force vector */
	const ScheduleT* fBodySchedule; /**< body force schedule */
	dArrayT fBody; /**< body force vector */
	
	/** shape functions */
	MeshFreeNodalShapeFunctionT* fNodalShapes;
	
	/** underlying Element connectivities. Needed only for MLS stuff right now */
	ArrayT<const iArray2DT*> fElementConnectivities;

	/** equation numbers */
	RaggedArray2DT<int> fEqnos;

	/* traction data */
	dArray2DT fTractionVectors;
	iArrayT fTractionBoundaryCondition;

};

} /* namespace Tahoe */

#endif /* _SCNIMF_T_H_ */


